{
  "metadata": {
    "version": "1.1",
    "created": "2025-08-18T23:15:15Z",
    "last_updated": "2025-08-19T00:00:00Z",
    "description": "Concept map for CSCD211 with prerequisite CSCD210 review and detailed topic breakdown.",
    "author": "Documentation Curator Agent",
    "audience": [
      "CSCD210 students",
      "CSCD211 students"
    ],
    "pedagogical_purpose": "Scaffolds knowledge from CSCD210 fundamentals to CSCD211 advanced concepts.",
    "total_nodes": 131,
    "total_links": 137
  },
  "nodes": [
    {
      "id": "cscd211",
      "name": "CSCD 211: Programming Principles II",
      "description": "Second programming course emphasizing object-oriented techniques, data abstraction, and Java collections.",
      "group": "course",
      "level": 0,
      "size": 24
    },
    {
      "id": "object-oriented-foundations",
      "name": "Object-Oriented Foundations",
      "description": "Building blocks of object-oriented design such as encapsulation, composition, and class structure.",
      "group": "object-oriented-foundations",
      "level": 1,
      "size": 18
    },
    {
      "id": "encapsulation",
      "name": "Encapsulation",
      "description": "Bundling data and behaviors to hide implementation details.",
      "group": "object-oriented-foundations",
      "level": 2,
      "size": 12
    },
    {
      "id": "getters-and-setters",
      "name": "Getters and Setters",
      "description": "Accessor methods that read or update private fields while preserving encapsulation.",
      "group": "object-oriented-foundations",
      "level": 3,
      "size": 6
    },
    {
      "id": "information-hiding",
      "name": "Information Hiding",
      "description": "Keeping implementation details private so other classes interact only through a public interface.",
      "group": "object-oriented-foundations",
      "level": 3,
      "size": 6
    },
    {
      "id": "immutability",
      "name": "Immutability",
      "description": "Designing objects whose state cannot change after construction, avoiding unexpected side effects.",
      "group": "object-oriented-foundations",
      "level": 3,
      "size": 6
    },
    {
      "id": "composition",
      "name": "Composition",
      "description": "Combining objects to build more complex behavior without inheritance.",
      "group": "object-oriented-foundations",
      "level": 2,
      "size": 12
    },
    {
      "id": "has-a-relationships",
      "name": "Has-a Relationships",
      "description": "Expresses ownership by embedding objects within others rather than inheriting from them.",
      "group": "object-oriented-foundations",
      "level": 3,
      "size": 6
    },
    {
      "id": "delegation",
      "name": "Delegation",
      "description": "Passing work to a contained object to reuse its behavior instead of duplicating code.",
      "group": "object-oriented-foundations",
      "level": 3,
      "size": 6
    },
    {
      "id": "reusable-components",
      "name": "Reusable Components",
      "description": "Small pieces of code designed to be combined into larger programs with minimal modification.",
      "group": "object-oriented-foundations",
      "level": 3,
      "size": 6
    },
    {
      "id": "class-design",
      "name": "Class Design",
      "description": "Planning fields, constructors, and methods for a coherent class.",
      "group": "object-oriented-foundations",
      "level": 2,
      "size": 12
    },
    {
      "id": "fields",
      "name": "Fields",
      "description": "Variables declared inside a class that store each object's state.",
      "group": "object-oriented-foundations",
      "level": 3,
      "size": 6
    },
    {
      "id": "constructors",
      "name": "Constructors",
      "description": "Special methods that initialize new objects, often overloading parameters to set starting values.",
      "group": "object-oriented-foundations",
      "level": 3,
      "size": 6
    },
    {
      "id": "methods",
      "name": "Methods",
      "description": "Named blocks of code that perform actions or compute results when called.",
      "group": "object-oriented-foundations",
      "level": 3,
      "size": 6
    },
    {
      "id": "access-modifiers",
      "name": "Access Modifiers",
      "description": "Keywords that control visibility of class members.",
      "group": "object-oriented-foundations",
      "level": 2,
      "size": 12
    },
    {
      "id": "public",
      "name": "public",
      "description": "Member access modifier allowing use from any other class.",
      "group": "object-oriented-foundations",
      "level": 3,
      "size": 6
    },
    {
      "id": "private",
      "name": "private",
      "description": "Member access modifier restricting use to within the defining class.",
      "group": "object-oriented-foundations",
      "level": 3,
      "size": 6
    },
    {
      "id": "protected",
      "name": "protected",
      "description": "Member access modifier allowing use within the package and subclasses.",
      "group": "object-oriented-foundations",
      "level": 3,
      "size": 6
    },
    {
      "id": "inheritance-and-polymorphism",
      "name": "Inheritance and Polymorphism",
      "description": "Using class hierarchies to reuse code and model relationships.",
      "group": "inheritance-and-polymorphism",
      "level": 1,
      "size": 18
    },
    {
      "id": "inheritance-hierarchies",
      "name": "Inheritance Hierarchies",
      "description": "Structuring classes to share and extend behavior.",
      "group": "inheritance-and-polymorphism",
      "level": 2,
      "size": 12
    },
    {
      "id": "base-class",
      "name": "Base Class",
      "description": "Parent type that provides common fields and behaviors for subclasses to inherit.",
      "group": "inheritance-and-polymorphism",
      "level": 3,
      "size": 6
    },
    {
      "id": "subclass",
      "name": "Subclass",
      "description": "Derived type that extends a base class, adding or customizing features.",
      "group": "inheritance-and-polymorphism",
      "level": 3,
      "size": 6
    },
    {
      "id": "extends-keyword",
      "name": "extends Keyword",
      "description": "Java keyword in a class declaration that indicates inheritance from a base class.",
      "group": "inheritance-and-polymorphism",
      "level": 3,
      "size": 6
    },
    {
      "id": "method-overriding",
      "name": "Method Overriding",
      "description": "Redefining inherited methods for specialized behavior.",
      "group": "inheritance-and-polymorphism",
      "level": 2,
      "size": 12
    },
    {
      "id": "override-annotation",
      "name": "@Override Annotation",
      "description": "Compiler hint showing a subclass method is intended to replace a superclass version.",
      "group": "inheritance-and-polymorphism",
      "level": 3,
      "size": 6
    },
    {
      "id": "runtime-binding",
      "name": "Runtime Binding",
      "description": "Selecting which overridden method to run based on the actual object's type at runtime.",
      "group": "inheritance-and-polymorphism",
      "level": 3,
      "size": 6
    },
    {
      "id": "super-keyword",
      "name": "super Keyword",
      "description": "Reference to the immediate superclass used to call its constructors or methods.",
      "group": "inheritance-and-polymorphism",
      "level": 3,
      "size": 6
    },
    {
      "id": "polymorphism",
      "name": "Polymorphism",
      "description": "Treating different objects uniformly through a shared interface.",
      "group": "inheritance-and-polymorphism",
      "level": 2,
      "size": 12
    },
    {
      "id": "dynamic-dispatch",
      "name": "Dynamic Dispatch",
      "description": "Mechanism that chooses an overridden method implementation when the program executes.",
      "group": "inheritance-and-polymorphism",
      "level": 3,
      "size": 6
    },
    {
      "id": "interface-implementation",
      "name": "Interface Implementation",
      "description": "Using the implements clause so a class promises to provide all interface methods.",
      "group": "inheritance-and-polymorphism",
      "level": 3,
      "size": 6
    },
    {
      "id": "polymorphic-collections",
      "name": "Polymorphic Collections",
      "description": "Containers that hold base-type references so elements of many subtypes can coexist.",
      "group": "inheritance-and-polymorphism",
      "level": 3,
      "size": 6
    },
    {
      "id": "liskov-substitution-principle",
      "name": "Liskov Substitution Principle",
      "description": "Subtypes must be substitutable for their base types without altering program correctness.",
      "group": "inheritance-and-polymorphism",
      "level": 2,
      "size": 12
    },
    {
      "id": "behavioral-contracts",
      "name": "Behavioral Contracts",
      "description": "Rules that define how a subtype must behave to remain a valid substitute for its base type.",
      "group": "inheritance-and-polymorphism",
      "level": 3,
      "size": 6
    },
    {
      "id": "substitution-safety",
      "name": "Substitution Safety",
      "description": "Guaranteeing that replacing a base type with a subtype will not break expected behavior.",
      "group": "inheritance-and-polymorphism",
      "level": 3,
      "size": 6
    },
    {
      "id": "type-hierarchies",
      "name": "Type Hierarchies",
      "description": "Layered arrangement of types where lower levels inherit characteristics from higher ones.",
      "group": "inheritance-and-polymorphism",
      "level": 3,
      "size": 6
    },
    {
      "id": "recursion",
      "name": "Recursion",
      "description": "Defining solutions that call themselves until reaching a base case.",
      "group": "recursion",
      "level": 1,
      "size": 18
    },
    {
      "id": "base-case",
      "name": "Base Case",
      "description": "The stopping condition that prevents infinite recursion.",
      "group": "recursion",
      "level": 2,
      "size": 12
    },
    {
      "id": "termination-condition",
      "name": "Termination Condition",
      "description": "Specific situation that signals a recursive function to stop calling itself.",
      "group": "recursion",
      "level": 3,
      "size": 6
    },
    {
      "id": "simplest-input",
      "name": "Simplest Input",
      "description": "The smallest or easiest case a recursive method can solve directly.",
      "group": "recursion",
      "level": 3,
      "size": 6
    },
    {
      "id": "no-further-calls",
      "name": "No Further Calls",
      "description": "Base case action that returns a result without making additional recursive calls.",
      "group": "recursion",
      "level": 3,
      "size": 6
    },
    {
      "id": "recursive-case",
      "name": "Recursive Case",
      "description": "The part of the algorithm that reduces the problem and calls itself.",
      "group": "recursion",
      "level": 2,
      "size": 12
    },
    {
      "id": "problem-reduction",
      "name": "Problem Reduction",
      "description": "Transforming a problem into a smaller instance that recursion can solve.",
      "group": "recursion",
      "level": 3,
      "size": 6
    },
    {
      "id": "self-call",
      "name": "Self Call",
      "description": "A recursive method invoking itself with modified arguments to work toward a solution.",
      "group": "recursion",
      "level": 3,
      "size": 6
    },
    {
      "id": "progress-toward-base",
      "name": "Progress Toward Base",
      "description": "Ensuring each recursive step moves closer to the base case to avoid infinite recursion.",
      "group": "recursion",
      "level": 3,
      "size": 6
    },
    {
      "id": "stack-frames",
      "name": "Stack Frames",
      "description": "Snapshot of a method call stored on the call stack.",
      "group": "recursion",
      "level": 2,
      "size": 12
    },
    {
      "id": "call-stack-growth",
      "name": "Call Stack Growth",
      "description": "Accumulation of stack frames as recursive calls build upon one another.",
      "group": "recursion",
      "level": 3,
      "size": 6
    },
    {
      "id": "parameter-preservation",
      "name": "Parameter Preservation",
      "description": "Retention of parameter values in each stack frame so returning calls have necessary context.",
      "group": "recursion",
      "level": 3,
      "size": 6
    },
    {
      "id": "unwinding",
      "name": "Unwinding",
      "description": "Phase where completed recursive calls return results back through the call stack.",
      "group": "recursion",
      "level": 3,
      "size": 6
    },
    {
      "id": "recursive-algorithms",
      "name": "Recursive Algorithms",
      "description": "Classic problems solved elegantly with recursion.",
      "group": "recursion",
      "level": 2,
      "size": 12
    },
    {
      "id": "factorial",
      "name": "Factorial",
      "description": "Recursive computation multiplying a number by every positive integer below it.",
      "group": "recursion",
      "level": 3,
      "size": 6
    },
    {
      "id": "fibonacci",
      "name": "Fibonacci",
      "description": "Sequence where each number is the sum of the two preceding numbers, often implemented recursively.",
      "group": "recursion",
      "level": 3,
      "size": 6
    },
    {
      "id": "binary-search",
      "name": "Binary Search",
      "description": "Algorithm that repeatedly divides a sorted list to locate a target value efficiently.",
      "group": "recursion",
      "level": 3,
      "size": 6
    },
    {
      "id": "data-structures-with-collections",
      "name": "Data Structures with Collections",
      "description": "Using Java collection classes to manage groups of objects.",
      "group": "data-structures-with-collections",
      "level": 1,
      "size": 18
    },
    {
      "id": "arraylist-usage",
      "name": "ArrayList Usage",
      "description": "Working with dynamic arrays that resize as needed.",
      "group": "data-structures-with-collections",
      "level": 2,
      "size": 12
    },
    {
      "id": "dynamic-array",
      "name": "Dynamic Array",
      "description": "Array-like structure that automatically expands when more capacity is needed.",
      "group": "data-structures-with-collections",
      "level": 3,
      "size": 6
    },
    {
      "id": "index-access",
      "name": "Index Access",
      "description": "Retrieving or updating an element directly by its numeric position.",
      "group": "data-structures-with-collections",
      "level": 3,
      "size": 6
    },
    {
      "id": "resizing",
      "name": "Resizing",
      "description": "Allocating a new underlying array and copying elements when capacity is exceeded.",
      "group": "data-structures-with-collections",
      "level": 3,
      "size": 6
    },
    {
      "id": "linkedlist-mechanics",
      "name": "LinkedList Mechanics",
      "description": "Managing elements connected through node references.",
      "group": "data-structures-with-collections",
      "level": 2,
      "size": 12
    },
    {
      "id": "node-structure",
      "name": "Node Structure",
      "description": "Fundamental linked-list element holding data and references to the next or previous nodes.",
      "group": "data-structures-with-collections",
      "level": 3,
      "size": 6
    },
    {
      "id": "head-and-tail",
      "name": "Head and Tail",
      "description": "Pointers to the first and last nodes that enable efficient insertion or traversal.",
      "group": "data-structures-with-collections",
      "level": 3,
      "size": 6
    },
    {
      "id": "traversal",
      "name": "Traversal",
      "description": "Visiting each node in a data structure in sequence to inspect or modify it.",
      "group": "data-structures-with-collections",
      "level": 3,
      "size": 6
    },
    {
      "id": "iterators",
      "name": "Iterators",
      "description": "Uniformly stepping through elements of a collection.",
      "group": "data-structures-with-collections",
      "level": 2,
      "size": 12
    },
    {
      "id": "hasnext-and-next",
      "name": "hasNext and next",
      "description": "Iterator methods that check for remaining elements and return them one at a time.",
      "group": "data-structures-with-collections",
      "level": 3,
      "size": 6
    },
    {
      "id": "for-each-loop",
      "name": "For-Each Loop",
      "description": "Enhanced loop syntax that uses an iterator behind the scenes to visit each element once.",
      "group": "data-structures-with-collections",
      "level": 3,
      "size": 6
    },
    {
      "id": "fail-fast-behavior",
      "name": "Fail-Fast Behavior",
      "description": "Iterator feature that throws an exception if the underlying collection changes during iteration.",
      "group": "data-structures-with-collections",
      "level": 3,
      "size": 6
    },
    {
      "id": "generics",
      "name": "Generics",
      "description": "Parameterizing types to write reusable, type-safe code.",
      "group": "data-structures-with-collections",
      "level": 2,
      "size": 12
    },
    {
      "id": "type-parameters",
      "name": "Type Parameters",
      "description": "Generic placeholders like <T> that let code work with any object type.",
      "group": "data-structures-with-collections",
      "level": 3,
      "size": 6
    },
    {
      "id": "compile-time-safety",
      "name": "Compile-Time Safety",
      "description": "Generics allow the compiler to catch type mismatches before running the program.",
      "group": "data-structures-with-collections",
      "level": 3,
      "size": 6
    },
    {
      "id": "diamond-operator",
      "name": "Diamond Operator",
      "description": "<> syntax that lets the compiler infer generic types from assignment context.",
      "group": "data-structures-with-collections",
      "level": 3,
      "size": 6
    },
    {
      "id": "interfaces-and-abstract-classes",
      "name": "Interfaces and Abstract Classes",
      "description": "Designing contracts and partial implementations for flexible architectures.",
      "group": "interfaces-and-abstract-classes",
      "level": 1,
      "size": 18
    },
    {
      "id": "interface-design",
      "name": "Interface Design",
      "description": "Specifying method signatures without implementation.",
      "group": "interfaces-and-abstract-classes",
      "level": 2,
      "size": 12
    },
    {
      "id": "public-methods",
      "name": "Public Methods",
      "description": "Interface methods are implicitly public so implementing classes can be used interchangeably.",
      "group": "interfaces-and-abstract-classes",
      "level": 3,
      "size": 6
    },
    {
      "id": "no-state",
      "name": "No State",
      "description": "Interfaces cannot store instance data, focusing solely on required method signatures.",
      "group": "interfaces-and-abstract-classes",
      "level": 3,
      "size": 6
    },
    {
      "id": "implementation-requirement",
      "name": "Implementation Requirement",
      "description": "Classes implementing an interface must provide concrete bodies for its methods.",
      "group": "interfaces-and-abstract-classes",
      "level": 3,
      "size": 6
    },
    {
      "id": "abstract-class-usage",
      "name": "Abstract Class Usage",
      "description": "Providing partial implementation that subclasses can extend.",
      "group": "interfaces-and-abstract-classes",
      "level": 2,
      "size": 12
    },
    {
      "id": "partial-implementation",
      "name": "Partial Implementation",
      "description": "Abstract classes supply reusable code while deferring some methods to subclasses.",
      "group": "interfaces-and-abstract-classes",
      "level": 3,
      "size": 6
    },
    {
      "id": "abstract-methods",
      "name": "Abstract Methods",
      "description": "Method declarations without bodies that force subclasses to define specific behavior.",
      "group": "interfaces-and-abstract-classes",
      "level": 3,
      "size": 6
    },
    {
      "id": "extends",
      "name": "extends",
      "description": "Keyword used so an abstract class inherits from another class or abstract parent.",
      "group": "interfaces-and-abstract-classes",
      "level": 3,
      "size": 6
    },
    {
      "id": "multiple-inheritance-via-interfaces",
      "name": "Multiple Inheritance via Interfaces",
      "description": "Combining capabilities by implementing several interfaces.",
      "group": "interfaces-and-abstract-classes",
      "level": 2,
      "size": 12
    },
    {
      "id": "implementing-multiple-interfaces",
      "name": "Implementing Multiple Interfaces",
      "description": "Listing several interfaces after implements so a class adopts multiple contracts.",
      "group": "interfaces-and-abstract-classes",
      "level": 3,
      "size": 6
    },
    {
      "id": "method-conflict-resolution",
      "name": "Method Conflict Resolution",
      "description": "Techniques for choosing which default method to inherit when interfaces define the same signature.",
      "group": "interfaces-and-abstract-classes",
      "level": 3,
      "size": 6
    },
    {
      "id": "marker-interfaces",
      "name": "Marker Interfaces",
      "description": "Empty interfaces used to tag classes for special processing or capabilities.",
      "group": "interfaces-and-abstract-classes",
      "level": 3,
      "size": 6
    },
    {
      "id": "default-methods",
      "name": "Default Methods",
      "description": "Supplying optional method bodies in interfaces.",
      "group": "interfaces-and-abstract-classes",
      "level": 2,
      "size": 12
    },
    {
      "id": "default-keyword",
      "name": "default Keyword",
      "description": "Allows an interface to provide a method body that implementers may inherit.",
      "group": "interfaces-and-abstract-classes",
      "level": 3,
      "size": 6
    },
    {
      "id": "backward-compatibility",
      "name": "Backward Compatibility",
      "description": "Default methods let interfaces evolve without forcing existing implementations to change.",
      "group": "interfaces-and-abstract-classes",
      "level": 3,
      "size": 6
    },
    {
      "id": "override-option",
      "name": "Override Option",
      "description": "Implementing classes may still provide their own version of an interface's default method.",
      "group": "interfaces-and-abstract-classes",
      "level": 3,
      "size": 6
    },
    {
      "id": "error-and-exception-handling",
      "name": "Error and Exception Handling",
      "description": "Managing runtime problems to keep programs robust.",
      "group": "error-and-exception-handling",
      "level": 1,
      "size": 18
    },
    {
      "id": "exception-hierarchy",
      "name": "Exception Hierarchy",
      "description": "Organized classes representing different error types.",
      "group": "error-and-exception-handling",
      "level": 2,
      "size": 12
    },
    {
      "id": "throwable",
      "name": "Throwable",
      "description": "Superclass for all objects that can be thrown and potentially caught.",
      "group": "error-and-exception-handling",
      "level": 3,
      "size": 6
    },
    {
      "id": "exception",
      "name": "Exception",
      "description": "Checked throwable indicating conditions a program might anticipate and handle.",
      "group": "error-and-exception-handling",
      "level": 3,
      "size": 6
    },
    {
      "id": "runtimeexception",
      "name": "RuntimeException",
      "description": "Unchecked throwable representing programming errors that may escape compilation checks.",
      "group": "error-and-exception-handling",
      "level": 3,
      "size": 6
    },
    {
      "id": "try-catch-finally",
      "name": "Try-Catch-Finally",
      "description": "Blocks that handle exceptions and guarantee cleanup.",
      "group": "error-and-exception-handling",
      "level": 2,
      "size": 12
    },
    {
      "id": "catch-blocks",
      "name": "Catch Blocks",
      "description": "Handles specific exceptions thrown in the try block to recover or react.",
      "group": "error-and-exception-handling",
      "level": 3,
      "size": 6
    },
    {
      "id": "finally-cleanup",
      "name": "Finally Cleanup",
      "description": "Section that always runs after try/catch to release resources or perform cleanup.",
      "group": "error-and-exception-handling",
      "level": 3,
      "size": 6
    },
    {
      "id": "resource-management",
      "name": "Resource Management",
      "description": "Practices that ensure files, streams, or other resources are closed even when errors occur.",
      "group": "error-and-exception-handling",
      "level": 3,
      "size": 6
    },
    {
      "id": "checked-vs-unchecked-exceptions",
      "name": "Checked vs Unchecked Exceptions",
      "description": "Distinguishing errors enforced at compile time from runtime faults.",
      "group": "error-and-exception-handling",
      "level": 2,
      "size": 12
    },
    {
      "id": "compile-time-checking",
      "name": "Compile-Time Checking",
      "description": "Requirement that checked exceptions are either caught or declared in the method signature.",
      "group": "error-and-exception-handling",
      "level": 3,
      "size": 6
    },
    {
      "id": "runtime-errors",
      "name": "Runtime Errors",
      "description": "Issues that arise while the program is running, often leading to exceptions.",
      "group": "error-and-exception-handling",
      "level": 3,
      "size": 6
    },
    {
      "id": "best-practices",
      "name": "Best Practices",
      "description": "Guidelines like catching specific exceptions and avoiding empty catch blocks.",
      "group": "error-and-exception-handling",
      "level": 3,
      "size": 6
    },
    {
      "id": "custom-exceptions",
      "name": "Custom Exceptions",
      "description": "Defining application-specific error types.",
      "group": "error-and-exception-handling",
      "level": 2,
      "size": 12
    },
    {
      "id": "extending-exception",
      "name": "Extending Exception",
      "description": "Creating a new exception class by inheriting from an existing exception type.",
      "group": "error-and-exception-handling",
      "level": 3,
      "size": 6
    },
    {
      "id": "constructors",
      "name": "Constructors",
      "description": "Special methods that initialize new objects, often overloading parameters to set starting values.",
      "group": "error-and-exception-handling",
      "level": 3,
      "size": 6
    },
    {
      "id": "meaningful-messages",
      "name": "Meaningful Messages",
      "description": "Supplying descriptive text in custom exceptions to aid debugging.",
      "group": "error-and-exception-handling",
      "level": 3,
      "size": 6
    },
    {
      "id": "prerequisite-review",
      "name": "Prerequisite Review",
      "description": "Essential CSCD210 knowledge that supports success in CSCD211.",
      "group": "prerequisite-review",
      "level": 1,
      "size": 18
    },
    {
      "id": "primitive-data-types",
      "name": "Primitive Data Types",
      "description": "Basic value types used to store simple data.",
      "group": "prerequisite-review",
      "level": 2,
      "size": 12
    },
    {
      "id": "int-type",
      "name": "int",
      "description": "Stores whole numbers such as -3, 0, or 42 without decimal points.",
      "group": "prerequisite-review",
      "level": 3,
      "size": 6
    },
    {
      "id": "double-type",
      "name": "double",
      "description": "Represents decimal numbers using double precision (e.g., 3.14).",
      "group": "prerequisite-review",
      "level": 3,
      "size": 6
    },
    {
      "id": "boolean-type",
      "name": "boolean",
      "description": "Holds a true or false value to guide conditional logic.",
      "group": "prerequisite-review",
      "level": 3,
      "size": 6
    },
    {
      "id": "char-type",
      "name": "char",
      "description": "Stores a single Unicode character like 'a' or '$'.",
      "group": "prerequisite-review",
      "level": 3,
      "size": 6
    },
    {
      "id": "type-conversion",
      "name": "Type Conversion",
      "description": "Changing data from one primitive type to another, such as casting an int to a double.",
      "group": "prerequisite-review",
      "level": 3,
      "size": 6
    },
    {
      "id": "variable-declaration",
      "name": "Variable Declaration",
      "description": "Introducing a named storage slot with a type and optional initial value.",
      "group": "prerequisite-review",
      "level": 3,
      "size": 6
    },
    {
      "id": "control-structures",
      "name": "Control Structures",
      "description": "Directing program flow with decisions and loops.",
      "group": "prerequisite-review",
      "level": 2,
      "size": 12
    },
    {
      "id": "if-else",
      "name": "if-else",
      "description": "Branching structure that executes different blocks depending on a boolean condition.",
      "group": "prerequisite-review",
      "level": 3,
      "size": 6
    },
    {
      "id": "for-and-while-loops",
      "name": "for and while loops",
      "description": "Repeated execution of code while a condition holds or for a set number of iterations.",
      "group": "prerequisite-review",
      "level": 3,
      "size": 6
    },
    {
      "id": "boolean-expressions",
      "name": "Boolean Expressions",
      "description": "Statements that evaluate to true or false and direct control flow.",
      "group": "prerequisite-review",
      "level": 3,
      "size": 6
    },
    {
      "id": "arrays",
      "name": "Arrays",
      "description": "Fixed-size collections of elements of the same type.",
      "group": "prerequisite-review",
      "level": 2,
      "size": 12
    },
    {
      "id": "declaration",
      "name": "Declaration",
      "description": "Statement that sets an array's type and name before allocation.",
      "group": "prerequisite-review",
      "level": 3,
      "size": 6
    },
    {
      "id": "indexing",
      "name": "Indexing",
      "description": "Accessing array elements via zero-based numeric positions.",
      "group": "prerequisite-review",
      "level": 3,
      "size": 6
    },
    {
      "id": "iteration",
      "name": "Iteration",
      "description": "Processing each element in sequence using loops or enhanced for statements.",
      "group": "prerequisite-review",
      "level": 3,
      "size": 6
    },
    {
      "id": "method-design",
      "name": "Method Design",
      "description": "Encapsulating behavior into reusable functions.",
      "group": "prerequisite-review",
      "level": 2,
      "size": 12
    },
    {
      "id": "parameters",
      "name": "Parameters",
      "description": "Values provided to a method so it can operate on external data.",
      "group": "prerequisite-review",
      "level": 3,
      "size": 6
    },
    {
      "id": "return-values",
      "name": "Return Values",
      "description": "Data a method sends back to its caller after completing execution.",
      "group": "prerequisite-review",
      "level": 3,
      "size": 6
    },
    {
      "id": "scope",
      "name": "Scope",
      "description": "Region in code where a declared name is valid and accessible.",
      "group": "prerequisite-review",
      "level": 3,
      "size": 6
    },
    {
      "id": "data-abstraction",
      "name": "Data Abstraction",
      "description": "Providing only essential interfaces while hiding implementation details.",
      "group": "data-abstraction",
      "level": 1,
      "size": 18
    },
    {
      "id": "inner-classes",
      "name": "Inner Classes",
      "description": "Classes defined within other classes for logical grouping and access to outer members.",
      "group": "inner-classes",
      "level": 1,
      "size": 18
    },
    {
      "id": "static-nested-class",
      "name": "Static Nested Class",
      "description": "Nested class declared static, independent of outer class instances.",
      "group": "inner-classes",
      "level": 2,
      "size": 12
    },
    {
      "id": "non-static-inner-class",
      "name": "Non-Static Inner Class",
      "description": "Inner class tied to an instance of the outer class, accessing its members.",
      "group": "inner-classes",
      "level": 2,
      "size": 12
    },
    {
      "id": "local-classes",
      "name": "Local Classes",
      "description": "Inner classes declared within a method or block for short-lived helpers.",
      "group": "inner-classes",
      "level": 2,
      "size": 12
    },
    {
      "id": "anonymous-inner-classes",
      "name": "Anonymous Inner Classes",
      "description": "One-off inner classes without a name, often used for event handlers.",
      "group": "inner-classes",
      "level": 2,
      "size": 12
    },
    {
      "id": "object-cloning",
      "name": "Object Cloning",
      "description": "Creating copies of objects with shallow or deep duplication strategies.",
      "group": "object-cloning",
      "level": 1,
      "size": 18
    },
    {
      "id": "shallow-copy",
      "name": "Shallow Copy",
      "description": "Cloning that copies references, causing shared sub-objects.",
      "group": "object-cloning",
      "level": 2,
      "size": 12
    },
    {
      "id": "deep-copy",
      "name": "Deep Copy",
      "description": "Cloning that duplicates nested objects for independence.",
      "group": "object-cloning",
      "level": 2,
      "size": 12
    },
    {
      "id": "cloneable-interface",
      "name": "Cloneable Interface",
      "description": "Marker interface indicating a class allows cloning via Object.clone().",
      "group": "object-cloning",
      "level": 2,
      "size": 12
    },
    {
      "id": "copy-constructors",
      "name": "Copy Constructors",
      "description": "Alternative cloning approach using a constructor that accepts an existing instance.",
      "group": "object-cloning",
      "level": 2,
      "size": 12
    }
  ],
  "links": [
    {
      "source": "cscd211",
      "target": "object-oriented-foundations",
      "type": "contains",
      "description": "CSCD 211: Programming Principles II covers Object-Oriented Foundations."
    },
    {
      "source": "object-oriented-foundations",
      "target": "encapsulation",
      "type": "contains",
      "description": "Object-Oriented Foundations includes Encapsulation."
    },
    {
      "source": "encapsulation",
      "target": "getters-and-setters",
      "type": "contains",
      "description": "Encapsulation relies on Getters and Setters."
    },
    {
      "source": "encapsulation",
      "target": "information-hiding",
      "type": "contains",
      "description": "Encapsulation relies on Information Hiding."
    },
    {
      "source": "encapsulation",
      "target": "immutability",
      "type": "contains",
      "description": "Encapsulation relies on Immutability."
    },
    {
      "source": "object-oriented-foundations",
      "target": "composition",
      "type": "contains",
      "description": "Object-Oriented Foundations includes Composition."
    },
    {
      "source": "composition",
      "target": "has-a-relationships",
      "type": "contains",
      "description": "Composition relies on Has-a Relationships."
    },
    {
      "source": "composition",
      "target": "delegation",
      "type": "contains",
      "description": "Composition relies on Delegation."
    },
    {
      "source": "composition",
      "target": "reusable-components",
      "type": "contains",
      "description": "Composition relies on Reusable Components."
    },
    {
      "source": "object-oriented-foundations",
      "target": "class-design",
      "type": "contains",
      "description": "Object-Oriented Foundations includes Class Design."
    },
    {
      "source": "class-design",
      "target": "fields",
      "type": "contains",
      "description": "Class Design relies on Fields."
    },
    {
      "source": "class-design",
      "target": "constructors",
      "type": "contains",
      "description": "Class Design relies on Constructors."
    },
    {
      "source": "class-design",
      "target": "methods",
      "type": "contains",
      "description": "Class Design relies on Methods."
    },
    {
      "source": "object-oriented-foundations",
      "target": "access-modifiers",
      "type": "contains",
      "description": "Object-Oriented Foundations includes Access Modifiers."
    },
    {
      "source": "access-modifiers",
      "target": "public",
      "type": "contains",
      "description": "Access Modifiers relies on public."
    },
    {
      "source": "access-modifiers",
      "target": "private",
      "type": "contains",
      "description": "Access Modifiers relies on private."
    },
    {
      "source": "access-modifiers",
      "target": "protected",
      "type": "contains",
      "description": "Access Modifiers relies on protected."
    },
    {
      "source": "cscd211",
      "target": "inheritance-and-polymorphism",
      "type": "contains",
      "description": "CSCD 211: Programming Principles II covers Inheritance and Polymorphism."
    },
    {
      "source": "inheritance-and-polymorphism",
      "target": "inheritance-hierarchies",
      "type": "contains",
      "description": "Inheritance and Polymorphism includes Inheritance Hierarchies."
    },
    {
      "source": "inheritance-hierarchies",
      "target": "base-class",
      "type": "contains",
      "description": "Inheritance Hierarchies relies on Base Class."
    },
    {
      "source": "inheritance-hierarchies",
      "target": "subclass",
      "type": "contains",
      "description": "Inheritance Hierarchies relies on Subclass."
    },
    {
      "source": "inheritance-hierarchies",
      "target": "extends-keyword",
      "type": "contains",
      "description": "Inheritance Hierarchies relies on extends Keyword."
    },
    {
      "source": "inheritance-and-polymorphism",
      "target": "method-overriding",
      "type": "contains",
      "description": "Inheritance and Polymorphism includes Method Overriding."
    },
    {
      "source": "method-overriding",
      "target": "override-annotation",
      "type": "contains",
      "description": "Method Overriding relies on @Override Annotation."
    },
    {
      "source": "method-overriding",
      "target": "runtime-binding",
      "type": "contains",
      "description": "Method Overriding relies on Runtime Binding."
    },
    {
      "source": "method-overriding",
      "target": "super-keyword",
      "type": "contains",
      "description": "Method Overriding relies on super Keyword."
    },
    {
      "source": "inheritance-and-polymorphism",
      "target": "polymorphism",
      "type": "contains",
      "description": "Inheritance and Polymorphism includes Polymorphism."
    },
    {
      "source": "polymorphism",
      "target": "dynamic-dispatch",
      "type": "contains",
      "description": "Polymorphism relies on Dynamic Dispatch."
    },
    {
      "source": "polymorphism",
      "target": "interface-implementation",
      "type": "contains",
      "description": "Polymorphism relies on Interface Implementation."
    },
    {
      "source": "polymorphism",
      "target": "polymorphic-collections",
      "type": "contains",
      "description": "Polymorphism relies on Polymorphic Collections."
    },
    {
      "source": "inheritance-and-polymorphism",
      "target": "liskov-substitution-principle",
      "type": "contains",
      "description": "Inheritance and Polymorphism includes Liskov Substitution Principle."
    },
    {
      "source": "liskov-substitution-principle",
      "target": "behavioral-contracts",
      "type": "contains",
      "description": "Liskov Substitution Principle relies on Behavioral Contracts."
    },
    {
      "source": "liskov-substitution-principle",
      "target": "substitution-safety",
      "type": "contains",
      "description": "Liskov Substitution Principle relies on Substitution Safety."
    },
    {
      "source": "liskov-substitution-principle",
      "target": "type-hierarchies",
      "type": "contains",
      "description": "Liskov Substitution Principle relies on Type Hierarchies."
    },
    {
      "source": "cscd211",
      "target": "recursion",
      "type": "contains",
      "description": "CSCD 211: Programming Principles II covers Recursion."
    },
    {
      "source": "recursion",
      "target": "base-case",
      "type": "contains",
      "description": "Recursion includes Base Case."
    },
    {
      "source": "base-case",
      "target": "termination-condition",
      "type": "contains",
      "description": "Base Case relies on Termination Condition."
    },
    {
      "source": "base-case",
      "target": "simplest-input",
      "type": "contains",
      "description": "Base Case relies on Simplest Input."
    },
    {
      "source": "base-case",
      "target": "no-further-calls",
      "type": "contains",
      "description": "Base Case relies on No Further Calls."
    },
    {
      "source": "recursion",
      "target": "recursive-case",
      "type": "contains",
      "description": "Recursion includes Recursive Case."
    },
    {
      "source": "recursive-case",
      "target": "problem-reduction",
      "type": "contains",
      "description": "Recursive Case relies on Problem Reduction."
    },
    {
      "source": "recursive-case",
      "target": "self-call",
      "type": "contains",
      "description": "Recursive Case relies on Self Call."
    },
    {
      "source": "recursive-case",
      "target": "progress-toward-base",
      "type": "contains",
      "description": "Recursive Case relies on Progress Toward Base."
    },
    {
      "source": "recursion",
      "target": "stack-frames",
      "type": "contains",
      "description": "Recursion includes Stack Frames."
    },
    {
      "source": "stack-frames",
      "target": "call-stack-growth",
      "type": "contains",
      "description": "Stack Frames relies on Call Stack Growth."
    },
    {
      "source": "stack-frames",
      "target": "parameter-preservation",
      "type": "contains",
      "description": "Stack Frames relies on Parameter Preservation."
    },
    {
      "source": "stack-frames",
      "target": "unwinding",
      "type": "contains",
      "description": "Stack Frames relies on Unwinding."
    },
    {
      "source": "recursion",
      "target": "recursive-algorithms",
      "type": "contains",
      "description": "Recursion includes Recursive Algorithms."
    },
    {
      "source": "recursive-algorithms",
      "target": "factorial",
      "type": "contains",
      "description": "Recursive Algorithms relies on Factorial."
    },
    {
      "source": "recursive-algorithms",
      "target": "fibonacci",
      "type": "contains",
      "description": "Recursive Algorithms relies on Fibonacci."
    },
    {
      "source": "recursive-algorithms",
      "target": "binary-search",
      "type": "contains",
      "description": "Recursive Algorithms relies on Binary Search."
    },
    {
      "source": "cscd211",
      "target": "data-structures-with-collections",
      "type": "contains",
      "description": "CSCD 211: Programming Principles II covers Data Structures with Collections."
    },
    {
      "source": "data-structures-with-collections",
      "target": "arraylist-usage",
      "type": "contains",
      "description": "Data Structures with Collections includes ArrayList Usage."
    },
    {
      "source": "arraylist-usage",
      "target": "dynamic-array",
      "type": "contains",
      "description": "ArrayList Usage relies on Dynamic Array."
    },
    {
      "source": "arraylist-usage",
      "target": "index-access",
      "type": "contains",
      "description": "ArrayList Usage relies on Index Access."
    },
    {
      "source": "arraylist-usage",
      "target": "resizing",
      "type": "contains",
      "description": "ArrayList Usage relies on Resizing."
    },
    {
      "source": "data-structures-with-collections",
      "target": "linkedlist-mechanics",
      "type": "contains",
      "description": "Data Structures with Collections includes LinkedList Mechanics."
    },
    {
      "source": "linkedlist-mechanics",
      "target": "node-structure",
      "type": "contains",
      "description": "LinkedList Mechanics relies on Node Structure."
    },
    {
      "source": "linkedlist-mechanics",
      "target": "head-and-tail",
      "type": "contains",
      "description": "LinkedList Mechanics relies on Head and Tail."
    },
    {
      "source": "linkedlist-mechanics",
      "target": "traversal",
      "type": "contains",
      "description": "LinkedList Mechanics relies on Traversal."
    },
    {
      "source": "data-structures-with-collections",
      "target": "iterators",
      "type": "contains",
      "description": "Data Structures with Collections includes Iterators."
    },
    {
      "source": "iterators",
      "target": "hasnext-and-next",
      "type": "contains",
      "description": "Iterators relies on hasNext and next."
    },
    {
      "source": "iterators",
      "target": "for-each-loop",
      "type": "contains",
      "description": "Iterators relies on For-Each Loop."
    },
    {
      "source": "iterators",
      "target": "fail-fast-behavior",
      "type": "contains",
      "description": "Iterators relies on Fail-Fast Behavior."
    },
    {
      "source": "data-structures-with-collections",
      "target": "generics",
      "type": "contains",
      "description": "Data Structures with Collections includes Generics."
    },
    {
      "source": "generics",
      "target": "type-parameters",
      "type": "contains",
      "description": "Generics relies on Type Parameters."
    },
    {
      "source": "generics",
      "target": "compile-time-safety",
      "type": "contains",
      "description": "Generics relies on Compile-Time Safety."
    },
    {
      "source": "generics",
      "target": "diamond-operator",
      "type": "contains",
      "description": "Generics relies on Diamond Operator."
    },
    {
      "source": "cscd211",
      "target": "interfaces-and-abstract-classes",
      "type": "contains",
      "description": "CSCD 211: Programming Principles II covers Interfaces and Abstract Classes."
    },
    {
      "source": "interfaces-and-abstract-classes",
      "target": "interface-design",
      "type": "contains",
      "description": "Interfaces and Abstract Classes includes Interface Design."
    },
    {
      "source": "interface-design",
      "target": "public-methods",
      "type": "contains",
      "description": "Interface Design relies on Public Methods."
    },
    {
      "source": "interface-design",
      "target": "no-state",
      "type": "contains",
      "description": "Interface Design relies on No State."
    },
    {
      "source": "interface-design",
      "target": "implementation-requirement",
      "type": "contains",
      "description": "Interface Design relies on Implementation Requirement."
    },
    {
      "source": "interfaces-and-abstract-classes",
      "target": "abstract-class-usage",
      "type": "contains",
      "description": "Interfaces and Abstract Classes includes Abstract Class Usage."
    },
    {
      "source": "abstract-class-usage",
      "target": "partial-implementation",
      "type": "contains",
      "description": "Abstract Class Usage relies on Partial Implementation."
    },
    {
      "source": "abstract-class-usage",
      "target": "abstract-methods",
      "type": "contains",
      "description": "Abstract Class Usage relies on Abstract Methods."
    },
    {
      "source": "abstract-class-usage",
      "target": "extends",
      "type": "contains",
      "description": "Abstract Class Usage relies on extends."
    },
    {
      "source": "interfaces-and-abstract-classes",
      "target": "multiple-inheritance-via-interfaces",
      "type": "contains",
      "description": "Interfaces and Abstract Classes includes Multiple Inheritance via Interfaces."
    },
    {
      "source": "multiple-inheritance-via-interfaces",
      "target": "implementing-multiple-interfaces",
      "type": "contains",
      "description": "Multiple Inheritance via Interfaces relies on Implementing Multiple Interfaces."
    },
    {
      "source": "multiple-inheritance-via-interfaces",
      "target": "method-conflict-resolution",
      "type": "contains",
      "description": "Multiple Inheritance via Interfaces relies on Method Conflict Resolution."
    },
    {
      "source": "multiple-inheritance-via-interfaces",
      "target": "marker-interfaces",
      "type": "contains",
      "description": "Multiple Inheritance via Interfaces relies on Marker Interfaces."
    },
    {
      "source": "interfaces-and-abstract-classes",
      "target": "default-methods",
      "type": "contains",
      "description": "Interfaces and Abstract Classes includes Default Methods."
    },
    {
      "source": "default-methods",
      "target": "default-keyword",
      "type": "contains",
      "description": "Default Methods relies on default Keyword."
    },
    {
      "source": "default-methods",
      "target": "backward-compatibility",
      "type": "contains",
      "description": "Default Methods relies on Backward Compatibility."
    },
    {
      "source": "default-methods",
      "target": "override-option",
      "type": "contains",
      "description": "Default Methods relies on Override Option."
    },
    {
      "source": "cscd211",
      "target": "error-and-exception-handling",
      "type": "contains",
      "description": "CSCD 211: Programming Principles II covers Error and Exception Handling."
    },
    {
      "source": "error-and-exception-handling",
      "target": "exception-hierarchy",
      "type": "contains",
      "description": "Error and Exception Handling includes Exception Hierarchy."
    },
    {
      "source": "exception-hierarchy",
      "target": "throwable",
      "type": "contains",
      "description": "Exception Hierarchy relies on Throwable."
    },
    {
      "source": "exception-hierarchy",
      "target": "exception",
      "type": "contains",
      "description": "Exception Hierarchy relies on Exception."
    },
    {
      "source": "exception-hierarchy",
      "target": "runtimeexception",
      "type": "contains",
      "description": "Exception Hierarchy relies on RuntimeException."
    },
    {
      "source": "error-and-exception-handling",
      "target": "try-catch-finally",
      "type": "contains",
      "description": "Error and Exception Handling includes Try-Catch-Finally."
    },
    {
      "source": "try-catch-finally",
      "target": "catch-blocks",
      "type": "contains",
      "description": "Try-Catch-Finally relies on Catch Blocks."
    },
    {
      "source": "try-catch-finally",
      "target": "finally-cleanup",
      "type": "contains",
      "description": "Try-Catch-Finally relies on Finally Cleanup."
    },
    {
      "source": "try-catch-finally",
      "target": "resource-management",
      "type": "contains",
      "description": "Try-Catch-Finally relies on Resource Management."
    },
    {
      "source": "error-and-exception-handling",
      "target": "checked-vs-unchecked-exceptions",
      "type": "contains",
      "description": "Error and Exception Handling includes Checked vs Unchecked Exceptions."
    },
    {
      "source": "checked-vs-unchecked-exceptions",
      "target": "compile-time-checking",
      "type": "contains",
      "description": "Checked vs Unchecked Exceptions relies on Compile-Time Checking."
    },
    {
      "source": "checked-vs-unchecked-exceptions",
      "target": "runtime-errors",
      "type": "contains",
      "description": "Checked vs Unchecked Exceptions relies on Runtime Errors."
    },
    {
      "source": "checked-vs-unchecked-exceptions",
      "target": "best-practices",
      "type": "contains",
      "description": "Checked vs Unchecked Exceptions relies on Best Practices."
    },
    {
      "source": "error-and-exception-handling",
      "target": "custom-exceptions",
      "type": "contains",
      "description": "Error and Exception Handling includes Custom Exceptions."
    },
    {
      "source": "custom-exceptions",
      "target": "extending-exception",
      "type": "contains",
      "description": "Custom Exceptions relies on Extending Exception."
    },
    {
      "source": "custom-exceptions",
      "target": "constructors",
      "type": "contains",
      "description": "Custom Exceptions relies on Constructors."
    },
    {
      "source": "custom-exceptions",
      "target": "meaningful-messages",
      "type": "contains",
      "description": "Custom Exceptions relies on Meaningful Messages."
    },
    {
      "source": "cscd211",
      "target": "prerequisite-review",
      "type": "contains",
      "description": "CSCD 211: Programming Principles II covers Prerequisite Review."
    },
    {
      "source": "prerequisite-review",
      "target": "primitive-data-types",
      "type": "contains",
      "description": "Prerequisite Review includes Primitive Data Types."
    },
    {
      "source": "primitive-data-types",
      "target": "int-type",
      "type": "contains",
      "description": "Primitive Data Types includes the int type for whole numbers."
    },
    {
      "source": "primitive-data-types",
      "target": "double-type",
      "type": "contains",
      "description": "Primitive Data Types includes the double type for decimal values."
    },
    {
      "source": "primitive-data-types",
      "target": "boolean-type",
      "type": "contains",
      "description": "Primitive Data Types includes the boolean type for logic."
    },
    {
      "source": "primitive-data-types",
      "target": "char-type",
      "type": "contains",
      "description": "Primitive Data Types includes the char type for single characters."
    },
    {
      "source": "primitive-data-types",
      "target": "type-conversion",
      "type": "contains",
      "description": "Primitive Data Types relies on Type Conversion."
    },
    {
      "source": "primitive-data-types",
      "target": "variable-declaration",
      "type": "contains",
      "description": "Primitive Data Types relies on Variable Declaration."
    },
    {
      "source": "prerequisite-review",
      "target": "control-structures",
      "type": "contains",
      "description": "Prerequisite Review includes Control Structures."
    },
    {
      "source": "control-structures",
      "target": "if-else",
      "type": "contains",
      "description": "Control Structures relies on if-else."
    },
    {
      "source": "control-structures",
      "target": "for-and-while-loops",
      "type": "contains",
      "description": "Control Structures relies on for and while loops."
    },
    {
      "source": "control-structures",
      "target": "boolean-expressions",
      "type": "contains",
      "description": "Control Structures relies on Boolean Expressions."
    },
    {
      "source": "prerequisite-review",
      "target": "arrays",
      "type": "contains",
      "description": "Prerequisite Review includes Arrays."
    },
    {
      "source": "arrays",
      "target": "declaration",
      "type": "contains",
      "description": "Arrays relies on Declaration."
    },
    {
      "source": "arrays",
      "target": "indexing",
      "type": "contains",
      "description": "Arrays relies on Indexing."
    },
    {
      "source": "arrays",
      "target": "iteration",
      "type": "contains",
      "description": "Arrays relies on Iteration."
    },
    {
      "source": "prerequisite-review",
      "target": "method-design",
      "type": "contains",
      "description": "Prerequisite Review includes Method Design."
    },
    {
      "source": "method-design",
      "target": "parameters",
      "type": "contains",
      "description": "Method Design relies on Parameters."
    },
    {
      "source": "method-design",
      "target": "return-values",
      "type": "contains",
      "description": "Method Design relies on Return Values."
    },
    {
      "source": "method-design",
      "target": "scope",
      "type": "contains",
      "description": "Method Design relies on Scope."
    },
    {
      "source": "primitive-data-types",
      "target": "encapsulation",
      "type": "prerequisite",
      "description": "Primitive Data Types connects to Encapsulation."
    },
    {
      "source": "control-structures",
      "target": "recursive-case",
      "type": "prerequisite",
      "description": "Control Structures connects to Recursive Case."
    },
    {
      "source": "arrays",
      "target": "arraylist-usage",
      "type": "prerequisite",
      "description": "Arrays connects to Arraylist Usage."
    },
    {
      "source": "method-design",
      "target": "class-design",
      "type": "prerequisite",
      "description": "Method Design connects to Class Design."
    },
    {
      "source": "inheritance-and-polymorphism",
      "target": "interfaces-and-abstract-classes",
      "type": "related",
      "description": "Inheritance And Polymorphism connects to Interfaces And Abstract Classes."
    },
    {
      "source": "recursive-algorithms",
      "target": "linkedlist-mechanics",
      "type": "related",
      "description": "Recursive Algorithms connects to Linkedlist Mechanics."
    },
    {
      "source": "cscd211",
      "target": "data-abstraction",
      "type": "contains",
      "description": "CSCD 211: Programming Principles II covers Data Abstraction."
    },
    {
      "source": "encapsulation",
      "target": "data-abstraction",
      "type": "prerequisite",
      "description": "Encapsulation enables Data Abstraction."
    },
    {
      "source": "cscd211",
      "target": "inner-classes",
      "type": "contains",
      "description": "CSCD 211: Programming Principles II covers Inner Classes."
    },
    {
      "source": "inner-classes",
      "target": "static-nested-class",
      "type": "contains",
      "description": "Inner Classes include Static Nested Class."
    },
    {
      "source": "inner-classes",
      "target": "non-static-inner-class",
      "type": "contains",
      "description": "Inner Classes include Non-Static Inner Class."
    },
    {
      "source": "inner-classes",
      "target": "local-classes",
      "type": "contains",
      "description": "Inner Classes include Local Classes."
    },
    {
      "source": "inner-classes",
      "target": "anonymous-inner-classes",
      "type": "contains",
      "description": "Inner Classes include Anonymous Inner Classes."
    },
    {
      "source": "cscd211",
      "target": "object-cloning",
      "type": "contains",
      "description": "CSCD 211: Programming Principles II covers Object Cloning."
    },
    {
      "source": "object-cloning",
      "target": "shallow-copy",
      "type": "contains",
      "description": "Object Cloning includes Shallow Copy."
    },
    {
      "source": "object-cloning",
      "target": "deep-copy",
      "type": "contains",
      "description": "Object Cloning includes Deep Copy."
    },
    {
      "source": "object-cloning",
      "target": "cloneable-interface",
      "type": "contains",
      "description": "Object Cloning uses the Cloneable Interface."
    },
    {
      "source": "object-cloning",
      "target": "copy-constructors",
      "type": "contains",
      "description": "Object Cloning can use Copy Constructors."
    }
  ]
}