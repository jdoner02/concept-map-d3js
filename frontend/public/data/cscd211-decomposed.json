{
  "metadata": {
    "version": "3.0",
    "created": "2025-08-18T23:15:15Z",
  "last_updated": "2025-08-19T00:15:00Z",
    "total_nodes": 34,
  "total_links": 58
  },
{
  "nodes": [
    {
      "id": "N0",
      "title": "CSCD 211 Programming Principles II",
      "description": "Continuation of Programming Principles I, focusing on advanced object-oriented concepts, data structures, and recursion. Topics include composition, recursion, data abstraction, polymorphism, inheritance, interfaces, inner classes, abstract classes, object cloning, array lists, linked lists, and exception handling:contentReference[oaicite:0]{index=0}. Programming projects emphasize the application of these concepts in Java."
    },
    {
      "id": "N1",
      "title": "Object-Oriented Programming Fundamentals",
      "description": "Core principles of object-oriented programming (OOP), building on basic class concepts. Covers defining classes and objects, encapsulating data and behavior, using object composition, understanding how objects are referenced in memory, and applying data abstraction principles in program design."
    },
    {
      "id": "N2",
      "title": "Classes and Objects Basics",
      "description": "The fundamentals of defining and using classes and objects in Java. Includes class structure (fields, methods, constructors), creating object instances, method invocation, and understanding the 'this' reference within instance methods."
    },
    {
      "id": "N3",
      "title": "Fields and Methods in Classes",
      "description": "Defining class attributes (fields) and behaviors (methods). Covers syntax for field declarations and method definitions, return types, parameters, and the concept of an instance vs. class (static) member. Students learn to design simple classes with attributes and corresponding methods."
    },
    {
      "id": "N4",
      "title": "Constructors and Initialization",
      "description": "How to initialize new objects using constructors. Covers defining constructors with parameters to set initial state, default constructors, and the use of constructor overloading for flexibility. Emphasizes ensuring objects start in a valid state."
    },
    {
      "id": "N5",
      "title": "The 'this' Reference",
      "description": "Understanding and using the `this` reference to refer to the current object instance. Explains how `this` is used to access fields and methods, pass the current object as a parameter, and resolve naming conflicts (such as shadowed variables)."
    },
    {
      "id": "N6",
      "title": "Method Overloading",
      "description": "Using method overloading to define multiple methods with the same name but different parameter lists. Covers how the compiler selects an overloaded method based on parameter types, and contrasts overloading with overriding (which is covered later)."
    },
    {
      "id": "N7",
      "title": "Class Fields (Attributes)",
      "description": "Class attributes that hold the state of an object. Discusses syntax (`type name`) for declaring fields inside a class, how fields can be instance-specific or static (shared across all instances), and the difference between fields and local variables."
    },
    {
      "id": "N8",
      "title": "Class Methods (Behaviors)",
      "description": "Functions defined inside a class that specify the behavior of objects. Covers method signatures (return type, name, parameters), how methods can access fields and parameters, and returning values. Introduces the concept of instance methods versus static methods."
    },
    {
      "id": "N9",
      "title": "Static vs Instance Members",
      "description": "Understanding static (class-level) fields and methods versus instance (object-level) fields and methods. Static members belong to the class as a whole and are shared, while instance members belong to individual objects. Covers when and how to use static fields/methods (e.g., constants, utility methods):contentReference[oaicite:1]{index=1}:contentReference[oaicite:2]{index=2}."
    },
    {
      "id": "N10",
      "title": "Field Declaration Syntax",
      "description": "Syntax and structure for declaring fields within a class, including specifying data type and field name. Understands that fields can be primitive types or object references."
    },
    {
      "id": "N11",
      "title": "Field Initialization and Default Values",
      "description": "Default values for uninitialized fields and ways to initialize fields (inline declarations or within constructors). Recognizes that object fields get default values (e.g., 0, null) if not explicitly set."
    },
    {
      "id": "N12",
      "title": "Accessing and Modifying Fields",
      "description": "How to access and modify fields. Covers using the dot notation (`object.fieldName`) from outside the class, and accessing fields directly or via `this.fieldName` inside instance methods."
    },
    {
      "id": "N13",
      "title": "Primitive Field Declaration",
      "description": "Declaring primitive-type fields (e.g., `int count;` inside class). Recognize syntax for primitives and that they are stored by value."
    },
    {
      "id": "N14",
      "title": "Object Reference Field Declaration",
      "description": "Declaring object reference fields (e.g., `String name;`). Understand that this creates a reference that can point to an object (or null):contentReference[oaicite:3]{index=3}."
    },
    {
      "id": "N15",
      "title": "Default Field Values",
      "description": "Default values assigned to fields if not explicitly initialized (e.g., 0 for numeric types, false for boolean, null for object references). Understand how uninitialized fields are handled by Java."
    },
    {
      "id": "N16",
      "title": "Field Initialization Methods",
      "description": "Ways to initialize fields: inline at declaration or in constructor. Understand how constructor initialization can set different values for different objects."
    },
    {
      "id": "N17",
      "title": "Accessing Fields Within Class",
      "description": "Accessing fields from within the class (in instance methods, possibly using `this`). Modify fields directly inside class methods."
    },
    {
      "id": "N18",
      "title": "Accessing Fields from Outside Class",
      "description": "Accessing or modifying fields from outside the class using an object reference (e.g., `obj.fieldName`). Requires appropriate access (usually public or via getters/setters)."
    },
    {
      "id": "N19",
      "title": "Declaring Primitive Fields",
      "description": "Ability to declare a primitive type field within a class with correct syntax and appropriate access modifier.",
      "rubric": {
        "Novice": "Struggles with basic syntax; may attempt to declare fields in the wrong place (e.g., inside methods) or omit type. Does not distinguish between a field and a local variable.",
        "Basic": "Can declare a simple primitive field but might use incorrect modifiers or naming conventions. May require reminders about placing declarations at the class level.",
        "Developing": "Correctly declares primitive fields with valid syntax (type and name) and appropriate visibility (e.g., private). Minor issues with style or understanding default values possible.",
        "Proficient": "Consistently declares primitive fields correctly, choosing appropriate data types and meaningful names. Understands where to declare fields and follows standard conventions without errors.",
        "Advanced": "Uses advanced knowledge to decide on optimal data types and modifiers for fields (e.g., using 'final' for constants). Demonstrates thorough understanding of field declarations in various scenarios.",
        "Mastery": "Effortlessly declares fields in complex designs, sets standards for code clarity and correctness. Can explain field declaration details to peers and uses best practices uniformly."
      }
    },
    {
      "id": "N20",
      "title": "Declaring Object Reference Fields",
      "description": "Ability to declare an object reference field (e.g., a String or custom object) and understand its default null value until initialized.",
      "rubric": {
        "Novice": "Attempts to declare object fields but may confuse object types with primitive types. Unclear that object fields default to null; might assume an object exists automatically.",
        "Basic": "Can declare a field of an object type when prompted, but may not initialize it or realize it starts as null. Might misuse it before initialization, causing null-pointer issues.",
        "Developing": "Properly declares object reference fields with correct types and syntax. Understands that these fields are references and are null if not assigned, though may occasionally forget initialization.",
        "Proficient": "Declares object fields appropriately, often initializing them in constructors or at declaration if needed. Clearly understands the need to instantiate objects before use to avoid null references.",
        "Advanced": "Shows fluency in managing object fields, including choosing appropriate reference types and handling cases where the field might remain null (e.g., optional associations). Rarely, if ever, encounters null-pointer errors due to uninitialized fields.",
        "Mastery": "Expertly designs classes with object fields, anticipating initialization needs and null conditions. Can implement complex object relationships confidently and instruct others on reference field pitfalls."
      }
    },
    {
      "id": "N21",
      "title": "Default Field Values Knowledge",
      "description": "Knowledge of the default values assigned to uninitialized fields of different types in Java.",
      "rubric": {
        "Novice": "Unaware of default values; assumes uninitialized fields have random or no value. Likely to produce errors by using fields without initializing, not realizing Java provides defaults.",
        "Basic": "Knows that fields have default values but may not recall specifics for each type (e.g., might know objects default to null but unsure about numeric defaults).",
        "Developing": "Can generally identify default values for common types (0 for numeric, false for boolean, null for object references) and avoids using fields without considering initialization, though might forget edge cases like char defaults.",
        "Proficient": "Clearly enumerates default values for all primitive types and object references. Never uses a field assuming a value without either initializing it or accounting for its default. Uses knowledge of defaults in debugging (e.g., recognizing null pointer causes).",
        "Advanced": "Leverages knowledge of default values in designing classes (for example, to differentiate between 'unset' and intentionally set fields). Rarely needs to check documentation for default behaviors; it's internalized knowledge.",
        "Mastery": "Has complete mastery of default values and uses this knowledge to write robust code. Can explain and predict object state before and after construction with respect to field defaults, guiding others in proper initialization practices."
      }
    },
    {
      "id": "N22",
      "title": "Field Initialization Techniques",
      "description": "Ability to correctly initialize fields either at declaration or within constructors and understanding the difference.",
      "rubric": {
        "Novice": "Does not initialize fields or does so incorrectly (e.g., tries to assign values outside of any method or constructor improperly). Unaware of constructor role in initialization.",
        "Basic": "Initializes fields only when explicitly told, possibly putting initialization in the wrong place (like each time in methods rather than in constructor or declaration). Understands that fields need values but not the structured approaches.",
        "Developing": "Initializes fields in constructors or at declaration for basic scenarios. Understands the two approaches but might not use the most appropriate one consistently (for example, always initializing at declaration even when different instances need different values).",
        "Proficient": "Chooses appropriate initialization strategy: uses constructor to set instance-specific values and declaration for constants or default initial values. Ensures all fields have intended values after object construction. Rarely leaves fields unintentionally null or defaulted.",
        "Advanced": "Designs classes with clear initialization paths; handles multiple constructors (overloading) ensuring all fields are properly set. Understands subtle details such as initialization order (static vs instance initializers) and leverages them correctly.",
        "Mastery": "Exhibits complete command over object initialization, even in complex scenarios (inheritance hierarchies, multiple static initializers). Can design and verify complex initialization flows and teach others how to properly initialize fields across different contexts."
      }
    },
    {
      "id": "N23",
      "title": "Using Fields Within Methods",
      "description": "Ability to use and modify fields from within the class's own methods (including using the `this` keyword when necessary).",
      "rubric": {
        "Novice": "Inside class methods, often confuses local variables and fields, maybe redeclaring variables instead of using fields. May not understand that `this.field` refers to the object's field.",
        "Basic": "Can access a field within a method if guided, but might forget to use `this` in scenarios where it's needed (like parameter shadowing) or might create unnecessary local copies of field values.",
        "Developing": "Comfortably reads and writes to fields inside instance methods, and uses `this` when distinguishing between fields and parameters if they have the same name. Occasionally minor mistakes, like shadowing a field without realizing.",
        "Proficient": "Directly manipulates object fields within class methods correctly. Uses `this` appropriately for clarity or disambiguation. Understands how field updates inside methods affect the object's state.",
        "Advanced": "Shows nuanced understanding, e.g., accessing inherited fields via `super` if needed, and can explain the use of `this` vs accessing directly. Never confuses local scope with field scope.",
        "Mastery": "Expertly manages object state via field access internally, even in complex classes. Instructs others on avoiding common mistakes like shadowing and demonstrates best practices (clear code, avoiding unnecessary use of `this` unless needed)."
      }
    },
    {
      "id": "N24",
      "title": "Accessing Fields via Objects",
      "description": "Ability to access and modify an object's public field from outside the class using object references (or via getters/setters for non-public fields).",
      "rubric": {
        "Novice": "Tries to access fields on objects without understanding of visibility (e.g., attempts to access private fields directly from outside). Syntax errors or runtime errors (if null objects) are common.",
        "Basic": "Can access public fields of an object with correct syntax (object.field), but may not consider whether the field is accessible or if the object is properly instantiated. Might misuse or not use accessor methods when needed.",
        "Developing": "Properly accesses fields that are intended to be public or uses provided getter/setter methods for private fields. Understands the difference between accessing a field and calling a method. Occasionally might expose fields that should be private or forget to check for null objects.",
        "Proficient": "Consistently uses object references to get or set field values correctly, with regard for access restrictions. Uses getters/setters appropriately and understands why direct access might be restricted. Checks that objects are not null before field access in code to avoid exceptions.",
        "Advanced": "Navigates object property access confidently, including through multiple object relationships (e.g., obj.subObj.field). Understands design principles, avoiding improper external modification of internal state. No issues with access control or null references.",
        "Mastery": "Possesses a deep understanding of object field access patterns. Can design APIs to expose data safely and access fields through them. Teaches others how to manage object state externally in a controlled manner and never makes mistakes regarding object state visibility or null safety."
      }
    },
    {
      "id": "N25",
      "title": "Encapsulation and Data Hiding",
      "description": "Protecting and managing access to an object's data. Focuses on using access modifiers to hide internal representation, and providing getters/setters or other interfaces to interact with data, maintaining class invariants."
    },
    {
      "id": "N26",
      "title": "Access Control Modifiers",
      "description": "The use of access level modifiers (private, public, protected, package-private) to control what parts of a program can see or modify class members. Emphasizes keeping fields private."
    },
    {
      "id": "N27",
      "title": "Accessor and Mutator Methods",
      "description": "Using accessor (get) and mutator (set) methods to provide controlled access to fields. Explains how these methods can enforce validations or invariants."
    },
    {
      "id": "N28",
      "title": "Encapsulation Benefits",
      "description": "Why encapsulation is important: maintenance, flexibility, and preventing external misuse. Discusses examples of how changing internal implementation doesn't affect other code if encapsulated properly."
    },
    {
      "id": "N29",
      "title": "Using Access Modifiers",
      "description": "Usage of private/public/protected: Typically, fields are private, methods often public for interface. Students learn to choose appropriate visibility to enforce encapsulation."
    },
    {
      "id": "N30",
      "title": "Implementing Getters and Setters",
      "description": "Design and implement getter and setter methods for class fields. Possibly discuss when to avoid setters (for immutable design)."
    },
    {
      "id": "N31",
      "title": "Rationale for Encapsulation",
      "description": "Understanding how encapsulation makes code maintainable and secure: e.g., can validate input in one place, change internal representation without breaking callers, etc."
    },
    {
      "id": "N32",
      "title": "Applying Access Modifiers",
      "description": "Ability to apply appropriate access modifiers to class members (fields and methods) to enforce encapsulation.",
      "rubric": {
        "Novice": "Makes most members public or default with no understanding of consequences. May not use any access modifiers or uses them incorrectly (e.g., marking everything public or confusing their meaning).",
        "Basic": "Aware of private vs public but inconsistent: might declare some fields private but then also make others public without reason. Might misuse protected/package without clear understanding. Encapsulation is partially applied but often circumvented.",
        "Developing": "Generally uses private for fields and public for necessary methods. May occasionally expose something inappropriately (like making a field public for convenience) but understands the concept of hiding data. Protected and package use is minimal or error-prone if attempted.",
        "Proficient": "Consistently marks fields private and only exposes what is necessary through public methods. Understands and occasionally uses protected/package appropriately (e.g., for subclass access or same-package collaboration). Encapsulation is maintained in design with few mistakes.",
        "Advanced": "Strategically uses all access levels as needed (private, protected, package, public) to create well-encapsulated classes and controlled extension points. Can justify the choice of modifier for each member. Rarely, if ever, exposes internal state unintentionally.",
        "Mastery": "Exemplary in enforcing encapsulation: fields are private (or protected with a clear inheritance reason), no internal implementation details leak out. Can mentor others on proper use of access modifiers and catch encapsulation issues in code reviews instantly."
      }
    },
    {
      "id": "N33",
      "title": "Using Getters and Setters",
      "description": "Ability to write getter and setter methods for a private field and use them to access or update the field value externally in a controlled manner.",
      "rubric": {
        "Novice": "Directly accesses fields from outside instead of writing getters/setters. If writing a setter/getter, might simply make the field public instead or write it incorrectly (e.g., not actually setting the field in setter).",
        "Basic": "Can create basic get and set methods when prompted, but might not see their purpose (e.g., get/set just returns/assigns without any logic, essentially replicating a public field). Sometimes forgets to use them in external code, still trying to access field directly.",
        "Developing": "Writes proper getters and setters for fields and uses them in outside code to interact with those fields. Understands they allow validation or future changes, though the student might not yet implement any validation. Rarely leaves fields public.",
        "Proficient": "Designs class interfaces with getters and setters where appropriate, and possibly avoids setters for fields that shouldn't be changed (demonstrating understanding of immutability). May include simple validation or transformation in these methods (e.g., refusing negative values in a setter).",
        "Advanced": "Uses getters/setters thoughtfully, adding necessary logic (like input checks or computed fields in getter) and documenting their use. Understands alternatives to setters (like more controlled methods) when appropriate. No longer just reflexively creates getters/setters for every field, but does so as needed by design.",
        "Mastery": "Creates clean and minimal class interfaces: uses accessors/mutators only when they make sense architecturally, otherwise uses constructor or other methods to enforce invariants. Implements non-trivial logic in these methods when needed (e.g., lazy loading in getters, notifying observers on set) and handles those expertly. Teaches encapsulation design choices (when to provide a setter or not) to others."
      }
    },
    {
      "id": "N34",
      "title": "Understanding Encapsulation Benefits",
      "description": "Understanding and articulation of why encapsulation is beneficial (e.g., ease of maintenance, preventing misuse, modularity).",
      "rubric": {
        "Novice": "Has no clear idea why one would make fields private or bother with encapsulation; might see it as unnecessary work. Cannot explain the impact of exposing internal data.",
        "Basic": "Knows at least one reason for encapsulation (like 'security' or 'to prevent direct changes') but explanation is shallow. Might parrot a definition without real comprehension or give vague benefits.",
        "Developing": "Can explain a couple of concrete benefits of encapsulation, such as the ability to change implementation without breaking external code and controlling valid values via setters. Understands that it helps catch errors and protect object integrity in basic terms.",
        "Proficient": "Clearly articulates multiple encapsulation advantages with examples: e.g., maintaining invariants, simplifying debugging (since changes funnel through setters), and improving code readability and manageability. Applies this understanding by consistently encapsulating in own code.",
        "Advanced": "Discusses encapsulation in terms of design principles (like information hiding in software engineering). Can analyze a design and point out where lack of encapsulation causes problems (like tight coupling or unintended dependencies). Uses advanced terms appropriately and can relate encapsulation to concept of abstraction.",
        "Mastery": "Expertly relates encapsulation to broader software architecture, possibly referencing principles like SRP (Single Responsibility Principle) or designing clear interfaces. Persuades others through clear reasoning and examples why encapsulation is crucial. Could write a short essay or give a talk on encapsulation best practices without preparation."
      }
    },
    {
      "id": "N35",
      "title": "Object Composition and Relationships",
      "description": "Using object references to build complex types. Covers the concept of classes having other objects as fields (\"has-a\" relationships) and how this differs from \"is-a\" (inheritance)."
    },
    {
      "id": "N36",
      "title": "Has-a Relationships (Composition)",
      "description": "Embedding objects within objects to model whole-part relationships. Example: a Car class having an Engine object field."
    },
    {
      "id": "N37",
      "title": "Composition vs Inheritance Design",
      "description": "Comparing composition to inheritance in designing class structures. Introduces the principle 'favor composition over inheritance':contentReference[oaicite:4]{index=4} and when to use each approach."
    },
    {
      "id": "N38",
      "title": "Associations: Aggregation vs Composition",
      "description": "Different types of associations between objects: simple association, aggregation (shared references), and composition (ownership). Explains conceptual differences and UML notation perhaps."
    },
    {
      "id": "N39",
      "title": "Using Object Fields for Composition",
      "description": "Defining classes that contain other class instances as fields to achieve complexity through composition."
    },
    {
      "id": "N40",
      "title": "Choosing Composition Over Inheritance",
      "description": "Deciding between using composition (has-a) or inheritance (is-a) when modeling a problem, and applying the guideline of favoring composition in ambiguous cases."
    },
    {
      "id": "N41",
      "title": "Understanding Object Association Types",
      "description": "Understanding how objects can relate: knowing when an object owns another (composition) vs simply references (aggregation), and how this impacts system design (e.g., lifetimes)."
    },
    {
      "id": "N42",
      "title": "Implementing Object Composition",
      "description": "Ability to design and implement a class that has fields which are references to other objects (composition), and use those fields to delegate tasks or model real-world relationships.",
      "rubric": {
        "Novice": "Does not utilize object fields; tries to represent all data with primitives or duplicate code instead of referencing another class. Might be confused by the idea of one object containing another and avoid it.",
        "Basic": "Can create a field of another class type if instructed, but may not fully understand how to use it. Tends to instantiate the contained object without considering sharing or null (e.g., always creates a new Engine inside Car even if should be provided). Limited interaction between the objects.",
        "Developing": "Comfortably composes objects (e.g., includes proper object fields and instantiates or injects them). Uses the contained object's methods to perform subtasks. Might not consider all design implications (like ownership or who should create the object), but the composition works in code.",
        "Proficient": "Designs classes with composition naturally when appropriate (prefers has-a for code reuse unless inheritance is clearly warranted). Ensures the composed object is properly managed (initialized, not left null unless intentional) and leverages it to simplify the containing class's logic.",
        "Advanced": "Uses composition to build flexible systems, possibly employing dependency injection or factories for composed objects. Avoids tight coupling even in composition (e.g., not hard-coding specific class types when not necessary). Clearly understands when one object should contain another versus just reference external objects.",
        "Mastery": "Expertly architects systems using composition. Can transform an inheritance-based design into a composition-based one to improve maintainability or vice versa with full justification. Leads discussions on design patterns that use composition (like Strategy pattern) and demonstrates deep understanding of object relationships."
      }
    },
    {
      "id": "N43",
      "title": "Evaluating Composition vs Inheritance",
      "description": "Ability to analyze a modeling problem and choose composition instead of inheritance when appropriate (following the 'favor composition' principle).",
      "rubric": {
        "Novice": "Defaults to inheritance for any relationship between classes or misuses inheritance (e.g., subclassing just to reuse code). Unaware of the principle of composition over inheritance; may create illogical hierarchies (like a Stack extends ArrayList example):contentReference[oaicite:5]{index=5}.",
        "Basic": "Heard of the concept that composition can be used, but decision-making is inconsistent. Might know not to always inherit but lacks clarity on why. Needs guidance to identify when to use a has-a relationship vs is-a.",
        "Developing": "Understands common scenarios where composition is preferable (e.g., to avoid inheriting unwanted behaviors or when classes don't form a true subtype relationship). Can follow the principle in straightforward cases, although complex designs might still confuse them.",
        "Proficient": "Consistently applies composition-over-inheritance in design. Before creating a subclass, checks if simpler to include an instance of the would-be parent. Avoids misuse of inheritance and can justify their design decisions in terms of flexibility and maintainability. Rarely designs something like a wrong hierarchy.",
        "Advanced": "Deeply comprehends the trade-offs between composition and inheritance. Can articulate multiple criteria for choosing one over the other (like Liskov Substitution Principle, ease of adding new behaviors, etc.). Uses composition to break up tasks and inherits only when the relationship is conceptually sound and needed for polymorphism.",
        "Mastery": "Could mentor others in object-oriented design, guiding them away from inheritance abuse. Recognizes subtle cases (like when inheritance is acceptable for type hierarchies vs when it causes issues). Might reference design patterns or SOLID principles to back decisions. Creates designs that elegantly use composition to maximize code reuse and minimize fragility."
      }
    },
    {
      "id": "N44",
      "title": "Differentiating Association Types",
      "description": "Understanding different object association types (association, aggregation, composition) and their implications (ownership, lifetime).",
      "rubric": {
        "Novice": "Has no understanding of the nuances of object relationships; sees any reference as the same. Unaware of concepts like one object 'owning' another or how lifetimes might be connected.",
        "Basic": "Recognizes that objects can connect, but not clear on formal terms. Might understand that some objects are part-of others (e.g., car-engine) but cannot articulate difference between a strong composition vs a loose reference.",
        "Developing": "Can differentiate basic scenarios: e.g., composition (parts that don't exist independently of whole) vs aggregation (shared references). Might not use the exact terminology but understands an object like Engine typically belongs to one Car. Sometimes uses UML or terms if taught, but with minor confusion.",
        "Proficient": "Clearly distinguishes association types and can identify them in examples. Uses the terms composition and aggregation appropriately and reasons about how deleting one object affects the other (e.g., if Car is destroyed, Engine might be too in composition). Applies these concepts to decide how to handle object lifetimes and references in code.",
        "Advanced": "Understands and teaches the subtle differences in object relationships, even in complex scenarios like graphs of objects. Might incorporate these concepts into code architecture (like deciding ownership for memory management in non-garbage-collected contexts, or for clarity in design). Fluent in UML notation for these relationships and uses them in documentation.",
        "Mastery": "Possesses a holistic view of system design involving multiple objects. Anticipates problems or patterns (like need for deep copy vs shallow copy) based on relationship types. Could design an entire model and explicitly manage compositions and aggregations for clarity and maintainability, mentoring others through the process."
      }
    },
    {
      "id": "N45",
      "title": "Memory Model and Reference Types",
      "description": "Understanding how Java manages memory for primitives vs objects. Focuses on variables as references for objects, implications of aliasing, and the concept of null and garbage collection."
    },
    {
      "id": "N46",
      "title": "Primitive vs Object Types",
      "description": "Differences between primitive types (stored by value) and object types (references to heap objects)."
    },
    {
      "id": "N47",
      "title": "Null References and NullPointerException",
      "description": "The meaning of null in Java, how references can be null, and handling NullPointerExceptions."
    },
    {
      "id": "N48",
      "title": "Object Aliasing and Side Effects",
      "description": "Aliasing: multiple references to the same object, and how changing through one reference affects others."
    },
    {
      "id": "N49",
      "title": "Garbage Collection Basics",
      "description": "Java's garbage collection: unreferenced objects and automatic memory management (no manual delete)."
    },
    {
      "id": "N50",
      "title": "Value vs Reference Semantics",
      "description": "Understanding that primitives hold values directly, whereas variables of object types hold references (pointers) to objects in memory."
    },
    {
      "id": "N51",
      "title": "Handling Null References",
      "description": "Knowing what null is, when a reference can be null, and how dereferencing null leads to exceptions, plus strategies to avoid NullPointerExceptions."
    },
    {
      "id": "N52",
      "title": "Effects of Reference Aliasing",
      "description": "Realizing that multiple variables can refer to the same object (aliasing) and understanding consequences (e.g., if one modifies the object, others see the change)."
    },
    {
      "id": "N53",
      "title": "Automatic Garbage Collection",
      "description": "Basic model of Java garbage collection: objects with no references get reclaimed, memory is automatic, and how this differs from manual memory management."
    },
    {
      "id": "N54",
      "title": "Distinguishing Value vs Reference",
      "description": "Ability to differentiate between primitive variables (storing actual values) and object reference variables (storing addresses pointing to objects).",
      "rubric": {
        "Novice": "Does not distinguish between primitives and objects; may think everything is an object or confuse how assignment works (e.g., expects two object variables to be independent like primitives).",
        "Basic": "Has a vague notion that the 'concept' of a structure (like a list) is separate from how it's built, but struggles to articulate it. Might list operations but also mixes in implementation details prematurely.",
        "Developing": "Understands that primitives copy their value on assignment while object variables copy a reference. Can predict simple scenarios (e.g., knows that after `a=b;` for objects, they refer to the same object). Might still slip up on more complex reference aliasing without tracing carefully.",
        "Proficient": "Comfortably models memory behavior for primitives and object references. Rarely makes mistakes in reasoning about assignment or equality (knows `==` vs `equals` differences as well). Can explain to others why two references alias or not after assignments.",
        "Advanced": "Deep understanding of Java's memory model: likely knows about string interning or other subtleties. Always uses the correct mental model when coding (no unintended aliasing issues). Can design examples or diagrams to illustrate reference vs value semantics to novices.",
        "Mastery": "Expert-level comprehension; could implement a simple model of Java memory in explanation. Predicts outcomes of complex reference scenarios (including passing references to methods, etc.) instantly. Sets an example by writing code that avoids misunderstandings (clear variable naming, copying objects when needed, etc.)."
      }
    },
    {
      "id": "N55",
      "title": "Null Safety Practices",
      "description": "Awareness of checking for null before usage and writing code to safely handle null references to avoid NullPointerExceptions.",
      "rubric": {
        "Novice": "Often dereferences object variables without considering null. Encounters NullPointerExceptions frequently and doesn't know why (e.g., calls methods on an object that was never initialized).",
        "Basic": "Knows that null is a 'no object' value and that it causes exceptions if used. May add some null checks sporadically (often after experiencing a crash) but not systematically. Possibly uses null in designs as a flag without alternatives.",
        "Developing": "Usually remembers to initialize objects or check for null when there's a possibility (e.g., after calling a method that might return null). Still might sometimes forget in edge cases. Understands the need for null checks and uses them in common scenarios (like before accessing array elements or object fields that might be null).",
        "Proficient": "Consistently ensures that null is handled - either by checking or by structuring code (initializing upfront or using optional patterns) to avoid null. Rarely hits a NullPointerException in own code. Understands patterns like defensive programming to avoid null issues.",
        "Advanced": "Has strategies to minimize null-related problems (for example, using `Optional` in Java 8+ or designing methods to return empty collections instead of null). Handles null elegantly when it must be allowed, and never neglects a potential null path in logic. Helps debug others' null issues effectively.",
        "Mastery": "Could practically eliminate null errors from a codebase through strong discipline and design. Possibly references the billion-dollar mistake (null) in explanation. Designs APIs to be null-safe or clearly document nullability. Coaches others in avoiding and handling null (e.g., using assertions, annotations for nullability, etc.)."
      }
    },
    {
      "id": "N56",
      "title": "Managing Aliasing Effects",
      "description": "Ability to recognize when two variables point to the same object and predict how changes via one reference will affect the other.",
      "rubric": {
        "Novice": "Does not realize two references refer to same object; might create unintended side effects (like modifying an object through one reference and being surprised it's modified when accessed via another reference).",
        "Basic": "Knows in theory that two references can alias the same object after assignment, but might not track it correctly. Sometimes writes code that unintentionally shares objects (like returning internal objects directly) leading to aliasing bugs.",
        "Developing": "Generally identifies when aliasing is happening. If they copy an object reference, they understand it points to the same object and are cautious modifying one. Might still make mistakes in complex structures (like aliasing in collections) but can debug them once pointed out.",
        "Proficient": "Actively considers aliasing in design: e.g., when passing objects to methods or storing them in multiple places. Prevents unintended side effects by making copies if needed or documenting that a method will mutate a passed object. Rarely caught off guard by aliasing issues.",
        "Advanced": "Anticipates aliasing pitfalls and designs around them. Could explain how Java's assignment and parameter passing cause aliasing or not. Uses immutability or defensive copying for important objects to avoid aliasing problems. Helps others understand shared reference problems through clear examples.",
        "Mastery": "Expert in managing object references: can analyze a large codebase and find subtle aliasing bugs. Implements or utilizes patterns to handle shared mutable state safely (like clone methods, copy constructors, or immutables). Could architect systems where aliasing is either harmless or carefully controlled and explain every decision."
      }
    },
    {
      "id": "N57",
      "title": "Understanding Garbage Collection",
      "description": "Basic understanding that Java automatically deallocates objects that are no longer referenced and that memory management is not manual.",
      "rubric": {
        "Novice": "Has little concept of memory management; may assume memory is infinite or worry about manual deletion like in other languages (or not know at all what happens to objects no longer used).",
        "Basic": "Understands that Java has garbage collection, meaning you don't explicitly free objects. However, might not realize implications (like memory leaks can still happen if references are unintentionally kept). Possibly confuses it, e.g., thinking setting an object to null immediately frees it.",
        "Developing": "Knows that unreferenced objects will be cleaned up eventually by the JVM. Doesn't attempt to free memory manually and trusts the GC. Might have a simplistic model (\"if no references, it's gone\") which works in general. Could still be unaware of performance aspects or finalization details.",
        "Proficient": "Understands garbage collection fairly well, including that it's non-deterministic and runs at intervals. Writes code that is GC-friendly (e.g., avoids unnecessary object retention). Aware of concepts like memory leaks via lingering references, and avoids common pitfalls (like using static collections that accidentally prevent GC).",
        "Advanced": "Possesses deeper knowledge of how the GC works (maybe can describe mark-and-sweep vs generational GC basics). Uses this knowledge when needed to troubleshoot memory issues or optimize, although in everyday coding still relies on GC to do its job. Ensures resources other than memory (files, etc.) are properly closed since GC won't handle those promptly.",
        "Mastery": "Expert-level insight into Java memory management and GC tuning. Could configure and optimize the garbage collector for a large application. Recognizes when an out-of-memory is due to genuine memory leak vs GC not catching up. Teaches others that while GC frees them from manual memory management, they still must manage object references carefully to allow GC to work."
      }
    },
    {
      "id": "N58",
      "title": "Data Abstraction Principles",
      "description": "Abstracting the implementation details behind public interfaces. Covers the idea of Abstract Data Types (ADTs), separating what a module does from how it does it, and prepares for concepts like interfaces/abstract classes."
    },
    {
      "id": "N59",
      "title": "Abstract Data Types (ADTs)",
      "description": "Abstract Data Types: defining data structures or types by their behavior (operations) rather than their implementation. E.g., a List ADT provides operations like add, remove, regardless of how it's implemented."
    },
    {
      "id": "N60",
      "title": "Interface vs Implementation Separation",
      "description": "Interface vs Implementation: distinguishing the public API (method signatures) from the internal code. Emphasizes that code using a class only needs to know the interface, not the inner workings."
    },
    {
      "id": "N61",
      "title": "OOP Mechanisms for Abstraction",
      "description": "Abstraction mechanisms in OOP: preview of using abstract classes and interfaces to achieve abstraction (specifics covered in Inheritance domain)."
    },
    {
      "id": "N62",
      "title": "List ADT and Implementations",
      "description": "Case Study: List as an abstract concept with ArrayList and LinkedList as two implementations. Shows how code can use the List interface without knowing which implementation is used."
    },
    {
      "id": "N63",
      "title": "Understanding ADT Concept",
      "description": "Concept of defining a type by its operations (methods) and behavior, not by how those operations are carried out. Students learn to think in terms of contracts (what operations do) rather than concrete algorithms at first."
    },
    {
      "id": "N64",
      "title": "Interface vs Implementation in Design",
      "description": "Realizing that users of a class rely on its interface (public methods) and should not depend on its private implementation. Encourages designing clear interfaces and hiding the implementation."
    },
    {
      "id": "N65",
      "title": "Abstract Classes and Interfaces (Preview)",
      "description": "Introduction to how Java provides abstraction: using abstract classes or interfaces to define abstract types. (Full details covered later, this is a high-level connection to the concept of abstraction.)"
    },
    {
      "id": "N66",
      "title": "List Example of Abstraction",
      "description": "Example demonstrating data abstraction: treating ArrayList and LinkedList both as List (abstract concept), highlighting how code can switch implementations without changing usage if written to the interface."
    },
    {
      "id": "N67",
      "title": "Describing ADTs by Operations",
      "description": "Ability to describe a structure or service purely in terms of operations (what it does) without specifying how it does it (implementation).",
      "rubric": {
        "Novice": "Focuses only on concrete implementations; cannot separate idea of 'what' vs 'how'. If asked to explain a data structure, dives into how it's coded rather than what operations it offers.",
        "Basic": "Has a vague notion that the 'concept' of a structure (like a list) is separate from how it's built, but struggles to articulate it. Might list operations but also mixes in implementation details prematurely.",
        "Developing": "Can list the operations of an ADT (e.g., push, pop for a Stack) and understand that multiple implementations (like array vs linked) could provide those operations. Sometimes still implementation-minded, but can pivot to thinking abstractly when prompted.",
        "Proficient": "Comfortably defines an ADT by its interface. For example, describes a Queue by enqueue/dequeue behavior without assuming a specific underlying representation. Understands the benefit: you can code to an interface and have multiple implementations.",
        "Advanced": "Articulates the ADT concept in broader terms, possibly referencing real-world analogies or formal definitions. Distinguishes clearly between specification and implementation. Could design their own ADT and separate these concerns cleanly.",
        "Mastery": "Deeply understands abstraction; can engage with formal specifications or contracts (pre/post-conditions) for an ADT. Able to teach others about thinking in terms of behavior and contracts. In coding, strictly codes against interfaces/ADTs and only later worries about the concrete strategy, demonstrating excellent abstraction skills."
      }
    },
    {
      "id": "N68",
      "title": "Separating Interface from Implementation",
      "description": "Skill in designing a class or module by first specifying its interface (public methods) and not exposing internal details (keeping fields and helpers hidden).",
      "rubric": {
        "Novice": "Designs classes with little regard for interface vs implementation; might expose internal data or change class internals frequently, causing breaks in other code. Doesn't grasp why hiding implementation matters.",
        "Basic": "Understands in theory that one shouldn't expose internal workings, but in practice might leak details (like returning a reference to an internal array directly). Possibly uses getters/setters without thought, sometimes effectively exposing fields anyway.",
        "Developing": "Usually keeps a clean separation: defines clear public methods and keeps fields private. If implementation changes, knows to update internals but keep method contracts consistent so external code isn't affected. May occasionally break abstraction (e.g., exposing too much in interface) due to oversight.",
        "Proficient": "Designs robust interfaces that encapsulate functionality well, allowing internal changes with minimal or no impact on callers. Rarely exposes implementation details unintentionally. Can refactor the inside of a class while keeping the interface the same to improve performance or structure.",
        "Advanced": "Thinks in terms of API design. Possibly writes documentation or comments in terms of what methods do, not how. Ensures that every public method has a clear purpose and hides everything else. Could guess the internal implementation from the interface but knows it's not guaranteed, highlighting strong abstraction.",
        "Mastery": "Excels in designing systems where each module is a black box with a well-defined interface. Can swap out entire components (implementations) behind the scenes without others knowing, due to strict adherence to interface contracts. Advocates for information hiding in all designs and demonstrates it consistently."
      }
    },
    {
      "id": "N69",
      "title": "Knowing Abstract Constructs",
      "description": "Basic understanding that Java provides 'interface' and 'abstract class' constructs to allow programmers to define abstract types (collections of method signatures) separate from any concrete implementation.",
      "rubric": {
        "Novice": "Not aware of abstract classes or interfaces; may think you can only define concrete classes. The idea of a class with unimplemented methods is foreign or confusing.",
        "Basic": "Has heard of interfaces or abstract classes, perhaps knows they exist, but doesn't understand why or how to use them. Might memorize that interfaces have no implementations (pre-Java8 context) but not the use case.",
        "Developing": "Understands that an interface is like a contract of methods and that abstract classes can provide partial implementations. Can explain that these are tools to achieve abstraction (like defining an ADT in code). Possibly can write a simple interface or abstract class if needed, though real use might still be unclear until more practice.",
        "Proficient": "Grasps that abstract classes and interfaces allow polymorphic behavior without tying to a concrete class. For example, can imagine a `Shape` abstract class or `List` interface and see how different subclasses/implementations fulfill those. Ready to apply them in designs when polymorphism is needed.",
        "Advanced": "Has likely used interfaces/abstract classes in code or at least in thought experiments. Understands nuances (like why Java has both, multiple inheritance issues, default methods in interfaces in newer Java). Could design a small hierarchy using an interface for abstraction and explain the rationale clearly.",
        "Mastery": "Possesses a deep conceptual and practical understanding. Anticipates when an interface or abstract base is needed to decouple design. Could explain and implement design patterns (like Strategy or Template Method) that rely on abstract classes/interfaces. Sets the stage for clean polymorphic architectures using these abstraction mechanisms."
      }
    },
    {
      "id": "N70",
      "title": "Using Interface (List) Instead of Implementation",
      "description": "Ability to use a List in Java (via the List interface) without needing to know whether it's an ArrayList or LinkedList underneath, demonstrating programming to an interface.",
      "rubric": {
        "Novice": "When asked to use a list, fixates on how it works (e.g., picks ArrayList and writes code specific to ArrayList, or reimplements list behavior manually). Doesn't grasp that the same interface can have multiple implementations.",
        "Basic": "Can use a List interface if told, but might not see the benefit. Perhaps writes `ArrayList<String> list = new ArrayList<>();` everywhere and never considers using the interface type in variables or method signatures. Slightly aware that LinkedList exists but unsure why one would switch.",
        "Developing": "Understands the concept: declares variables of type List, and can swap between ArrayList and LinkedList if needed with minimal code changes. Appreciates that as long as it supports List methods, their code works. Might still default to one implementation without evaluating which is better, but knows alternatives exist.",
        "Proficient": "Comfortably programs to the List interface. Chooses implementations based on context (e.g., uses ArrayList vs LinkedList if reasoning about performance). Could write a method that takes `List<Something>` and works for any implementation. Fully grasps that their code doesn't need to change if the list implementation changes.",
        "Advanced": "Demonstrates abstraction by possibly using other implementations (like custom List) in the same code seamlessly. Understands the underlying differences but keeps code at the interface level for flexibility. Could explain how, for instance, using `List` allows later switching to a thread-safe list or a different policy without rewriting code.",
        "Mastery": "Exemplifies programming to interfaces in all code. Might design own interfaces for abstractions in projects. In the List example, not only uses List correctly but also educates others on why that abstraction is powerful. Could build a new List implementation and integrate it without modifying client code at all, proving the abstraction's value."
      }
    }
    // ... (Additional nodes for Inheritance & Polymorphism domain, Data Structures domain, Recursion domain, and Advanced Java Features domain would continue in a similar structured manner, ensuring every concept down to atomic skills is represented with rubric. Due to space, only the Object-Oriented Fundamentals domain is fully expanded above as an example of the structure.)
  ],
  "links": [
    { "source": "N0", "target": "N1" },
    { "source": "N1", "target": "N2" },
    { "source": "N2", "target": "N3" },
    { "source": "N2", "target": "N4" },
    { "source": "N2", "target": "N5" },
    { "source": "N2", "target": "N6" },
    { "source": "N3", "target": "N7" },
    { "source": "N3", "target": "N8" },
    { "source": "N3", "target": "N9" },
    { "source": "N7", "target": "N10" },
    { "source": "N7", "target": "N11" },
    { "source": "N7", "target": "N12" },
    { "source": "N10", "target": "N13" },
    { "source": "N10", "target": "N14" },
    { "source": "N11", "target": "N15" },
    { "source": "N11", "target": "N16" },
    { "source": "N12", "target": "N17" },
    { "source": "N12", "target": "N18" },
    { "source": "N13", "target": "N19" },
    { "source": "N14", "target": "N20" },
    { "source": "N15", "target": "N21" },
    { "source": "N16", "target": "N22" },
    { "source": "N17", "target": "N23" },
    { "source": "N18", "target": "N24" },
    { "source": "N1", "target": "N25" },
    { "source": "N25", "target": "N26" },
    { "source": "N25", "target": "N27" },
    { "source": "N25", "target": "N28" },
    { "source": "N26", "target": "N29" },
    { "source": "N27", "target": "N30" },
    { "source": "N28", "target": "N31" },
    { "source": "N29", "target": "N32" },
    { "source": "N30", "target": "N33" },
    { "source": "N31", "target": "N34" },
    { "source": "N1", "target": "N35" },
    { "source": "N35", "target": "N36" },
    { "source": "N35", "target": "N37" },
    { "source": "N35", "target": "N38" },
    { "source": "N36", "target": "N39" },
    { "source": "N37", "target": "N40" },
    { "source": "N38", "target": "N41" },
    { "source": "N39", "target": "N42" },
    { "source": "N40", "target": "N43" },
    { "source": "N41", "target": "N44" },
    { "source": "N1", "target": "N45" },
    { "source": "N45", "target": "N46" },
    { "source": "N45", "target": "N47" },
    { "source": "N45", "target": "N48" },
    { "source": "N45", "target": "N49" },
    { "source": "N46", "target": "N50" },
    { "source": "N47", "target": "N51" },
    { "source": "N48", "target": "N52" },
    { "source": "N49", "target": "N53" },
    { "source": "N50", "target": "N54" },
    { "source": "N51", "target": "N55" },
    { "source": "N52", "target": "N56" },
    { "source": "N53", "target": "N57" },
    { "source": "N1", "target": "N58" },
    { "source": "N58", "target": "N59" },
    { "source": "N58", "target": "N60" },
    { "source": "N58", "target": "N61" },
    { "source": "N58", "target": "N62" },
    { "source": "N59", "target": "N63" },
    { "source": "N60", "target": "N64" },
    { "source": "N61", "target": "N65" },
    { "source": "N62", "target": "N66" },
    { "source": "N63", "target": "N67" },
    { "source": "N64", "target": "N68" },
    { "source": "N65", "target": "N69" },
    { "source": "N66", "target": "N70" },
    // ... (Additional links connecting all remaining domains and nodes appropriately)
  ]
}
