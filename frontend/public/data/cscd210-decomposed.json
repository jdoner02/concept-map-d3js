{
  "metadata": {
    "version": "2.0",
    "created": "2025-08-20T00:00:00Z",
    "last_updated": "2025-08-20T00:00:00Z",
    "description": "CSCD210 concept map aligned with official course description and Java-focused content.",
    "total_nodes": 361,
    "total_links": 360
  },
  "nodes": [
    {
      "id": "CSCD210",
      "title": "CSCD 210 Programming Principles I",
      "name": "CSCD 210 Programming Principles I",
      "description": "This course covers the concepts and practices of information representation, computer algorithms, hardware organization and computer program design and implementation. Students write, run, debug, analyze and evaluate computer programs. Topics include primitive data types, number systems, file I/O classes, control structures, method design and usage, array\u2013sorting and searching algorithms. Programming projects are required.",
      "level": 0
    },
    {
      "id": "CSCD210-D1",
      "title": "Information Representation & Number Systems",
      "name": "Information Representation & Number Systems",
      "description": "Binary and other base systems, data encoding, and how hardware stores primitive values.",
      "level": 1
    },
    {
      "id": "CSCD210-D1-S1",
      "title": "Binary Digits & Bits",
      "name": "Binary Digits & Bits",
      "description": "Bit-level interpretation and two's complement for signed values.",
      "level": 2
    },
    {
      "id": "CSCD210-D1-S1-C1",
      "title": "Bit Values",
      "name": "Bit Values",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D1-S1-C1-A1",
      "title": "Compute decimal value of any bit position",
      "name": "Compute decimal value of any bit position",
      "description": "Students learn to calculate the decimal value represented by each position in a binary number using powers of 2. Common misconception: Students often confuse bit position counting (starting from 0 at rightmost) with mathematical position (starting from 1). Teaching remedy: Use visual aids showing position labels clearly marked, and emphasize that bit position n has value 2^n.",
      "level": 4,
      "learning_objectives": [
        "Calculate 2^n for any bit position n",
        "Convert single bit positions to decimal values",
        "Understand positional notation in binary system"
      ],
      "common_misconceptions": [
        {
          "misconception": "Counting bit positions from 1 instead of 0",
          "remedy": "Practice with labeled diagrams showing position indices, emphasize computer science indexing convention"
        },
        {
          "misconception": "Confusing bit position with bit value",
          "remedy": "Use clear terminology: position vs. value, demonstrate with examples like 'position 3 can hold value 0 or 1'"
        }
      ],
      "prerequisites": ["basic exponent arithmetic", "understanding of place value in decimal system"],
      "assessment_strategies": ["bit position calculation exercises", "binary-to-decimal conversion practice"]
    },
    {
      "id": "CSCD210-D1-S1-C1-A2",
      "title": "Differentiate between most and least significant bits",
      "name": "Differentiate between most and least significant bits",
      "description": "Students distinguish between the leftmost bit (most significant bit or MSB) which has the highest positional value, and the rightmost bit (least significant bit or LSB) which has the lowest positional value. Common misconception: Students may think 'significant' refers to importance rather than mathematical weight. Teaching remedy: Emphasize that significance refers to the magnitude of impact on the overall number value.",
      "level": 4,
      "learning_objectives": [
        "Identify MSB and LSB in any binary number",
        "Explain the impact of changing MSB vs LSB on total value",
        "Understand why MSB changes have greater effect on number magnitude"
      ],
      "common_misconceptions": [
        {
          "misconception": "Thinking 'significance' means importance rather than magnitude",
          "remedy": "Use concrete examples showing how changing MSB vs LSB affects the decimal value differently"
        },
        {
          "misconception": "Confusing left/right orientation with significance",
          "remedy": "Practice with numbers written in different orientations, emphasize positional weight concept"
        }
      ],
      "prerequisites": ["bit position numbering", "positional notation understanding"],
      "assessment_strategies": ["MSB/LSB identification exercises", "impact analysis of bit changes"]
    },
    {
      "id": "CSCD210-D1-S1-C1-A3",
      "title": "Distinguish bit, byte, and word sizes",
      "name": "Distinguish bit, byte, and word sizes",
      "description": "Students learn the hierarchical relationship between bits (single binary digits), bytes (8 bits), and words (architecture-dependent, typically 32 or 64 bits). Common misconception: Students often assume word size is universal rather than processor-dependent. Teaching remedy: Show examples from different processor architectures and explain how Java abstracts these differences.",
      "level": 4,
      "learning_objectives": [
        "Define bit, byte, and word in computer architecture context",
        "Calculate number of possible values for different data sizes",
        "Understand why data size affects memory usage and performance"
      ],
      "common_misconceptions": [
        {
          "misconception": "Assuming word size is always the same across all computers",
          "remedy": "Show examples of 32-bit vs 64-bit systems, explain architecture dependency"
        },
        {
          "misconception": "Thinking bigger data types are always better",
          "remedy": "Discuss memory efficiency trade-offs, show when smaller types are appropriate"
        }
      ],
      "prerequisites": ["basic binary understanding", "concept of memory storage"],
      "assessment_strategies": ["data size calculation problems", "memory efficiency analysis exercises"]
    },
    {
      "id": "CSCD210-D1-S1-C2",
      "title": "Binary Addition",
      "name": "Binary Addition",
      "description": "Students learn to perform addition operations directly in binary, understanding how carries propagate through bit positions. This fundamental skill underpins all computer arithmetic operations. Common difficulty: Students often try to convert to decimal, add, then convert back rather than working directly in binary.",
      "level": 3,
      "learning_objectives": [
        "Perform binary addition without decimal conversion",
        "Track carry propagation through multiple bit positions",
        "Recognize patterns in binary arithmetic"
      ],
      "pedagogical_approach": "Start with single-bit addition (0+0, 0+1, 1+0, 1+1), then progress to multi-bit problems with increasing complexity",
      "common_difficulties": [
        "Forgetting to propagate carries correctly",
        "Mixing up binary and decimal addition rules",
        "Losing track of bit positions in longer numbers"
      ]
    },
    {
      "id": "CSCD210-D1-S1-C2-A1",
      "title": "Perform binary addition with carries",
      "name": "Perform binary addition with carries",
      "description": "Students master the four basic binary addition cases: 0+0=0, 0+1=1, 1+0=1, 1+1=10 (with carry). They learn to track carries across multiple bit positions. Common misconception: Students often write 1+1=2 instead of 1+1=10 in binary. Teaching remedy: Emphasize that in binary, there are only digits 0 and 1, so 'two' must be written as '10'.",
      "level": 4,
      "learning_objectives": [
        "Execute all four binary addition combinations correctly",
        "Manage carry propagation across multiple bit positions",
        "Verify results using decimal conversion check"
      ],
      "common_misconceptions": [
        {
          "misconception": "Writing 1+1=2 instead of 1+1=10 in binary",
          "remedy": "Repeatedly emphasize binary has only digits 0 and 1, practice with visual carry tracking"
        },
        {
          "misconception": "Forgetting to carry when adding 1+1+carry",
          "remedy": "Use step-by-step templates that force students to check for carries at each position"
        }
      ],
      "prerequisites": ["understanding of binary digits", "concept of positional notation"],
      "assessment_strategies": ["step-by-step binary addition problems", "carry propagation exercises"]
    },
    {
      "id": "CSCD210-D1-S1-C2-A2",
      "title": "Detect overflow in fixed-width sums",
      "name": "Detect overflow in fixed-width sums",
      "description": "Students learn to recognize when addition results exceed the storage capacity of fixed-width binary representations (e.g., 4-bit, 8-bit). Common misconception: Students often ignore overflow assuming infinite precision. Teaching remedy: Use concrete examples showing how computers have finite storage and what happens when calculations exceed capacity.",
      "level": 4,
      "learning_objectives": [
        "Calculate maximum representable value for given bit width",
        "Identify when addition results cause overflow",
        "Understand real-world implications of integer overflow"
      ],
      "common_misconceptions": [
        {
          "misconception": "Assuming computers handle arbitrarily large numbers",
          "remedy": "Demonstrate actual overflow examples in Java with int and long types"
        },
        {
          "misconception": "Thinking overflow always causes errors",
          "remedy": "Show how overflow often causes silent wraparound, discuss security implications"
        }
      ],
      "prerequisites": ["binary addition skills", "understanding of data type limits"],
      "assessment_strategies": ["overflow detection exercises", "fixed-width arithmetic problems"]
    },
    {
      "id": "CSCD210-D1-S1-C2-A3",
      "title": "Explain two's complement representation",
      "name": "Explain two's complement representation",
      "description": "Students understand how computers represent negative numbers using two's complement, where the most significant bit indicates sign and negative values are formed by inverting all bits and adding 1. Common difficulty: Students struggle with why two's complement is used instead of simple sign-magnitude. Teaching remedy: Demonstrate how two's complement allows the same addition circuitry to work for both positive and negative numbers.",
      "level": 4,
      "learning_objectives": [
        "Convert positive numbers to two's complement negative representation",
        "Explain why two's complement is preferred over sign-magnitude",
        "Perform arithmetic with two's complement numbers"
      ],
      "common_misconceptions": [
        {
          "misconception": "Thinking the leftmost bit is just a simple sign bit",
          "remedy": "Show that MSB has negative weight in two's complement, not just sign indication"
        },
        {
          "misconception": "Believing two's complement is unnecessarily complex",
          "remedy": "Demonstrate hardware efficiency: same circuits work for addition and subtraction"
        }
      ],
      "prerequisites": ["binary arithmetic", "understanding of negative numbers"],
      "assessment_strategies": ["two's complement conversion exercises", "signed arithmetic problems"]
    },
    {
      "id": "CSCD210-D1-S1-C3",
      "title": "Overflow Detection",
      "name": "Overflow Detection",
      "description": "Students learn to identify when arithmetic operations exceed the representable range of a data type, distinguishing between unsigned overflow (wrapping around) and signed overflow (potentially changing sign). This concept is critical for understanding program reliability and security vulnerabilities.",
      "level": 3,
      "learning_objectives": [
        "Recognize signs of overflow in arithmetic operations",
        "Distinguish between unsigned and signed overflow behavior",
        "Understand security and reliability implications of overflow"
      ],
      "pedagogical_approach": "Use visual representations showing number lines and wraparound behavior, connect to real-world examples of overflow bugs",
      "real_world_connections": [
        "Y2K problem as date overflow example",
        "Video game score rollover bugs",
        "Security vulnerabilities from integer overflow"
      ]
    },
    {
      "id": "CSCD210-D1-S1-C3-A1",
      "title": "Contrast signed and unsigned overflow",
      "name": "Contrast signed and unsigned overflow",
      "description": "Students understand that unsigned integers wrap around to zero when they exceed maximum value, while signed integers may flip from positive to negative due to two's complement representation. Common misconception: Students expect all overflow to behave the same way. Teaching remedy: Demonstrate with concrete examples using Java's int vs long behavior, and show unsigned behavior using languages or methods that support unsigned arithmetic.",
      "level": 4,
      "learning_objectives": [
        "Predict overflow behavior for unsigned integers",
        "Predict overflow behavior for signed integers",
        "Explain why signed overflow can cause negative results"
      ],
      "common_misconceptions": [
        {
          "misconception": "Expecting consistent overflow behavior across all data types",
          "remedy": "Show side-by-side examples of signed vs unsigned overflow with visual number lines"
        },
        {
          "misconception": "Thinking overflow always causes program crashes",
          "remedy": "Demonstrate silent overflow in Java, show how programs continue with wrong values"
        }
      ],
      "prerequisites": ["two's complement understanding", "data type ranges"],
      "assessment_strategies": ["overflow prediction exercises", "comparison analysis problems"]
    },
    {
      "id": "CSCD210-D1-S1-C3-A2",
      "title": "Identify limits for n-bit integers",
      "name": "Identify limits for n-bit integers",
      "description": "Students calculate the minimum and maximum representable values for integers of any bit width, understanding that unsigned n-bit integers range from 0 to 2^n-1, while signed n-bit integers range from -2^(n-1) to 2^(n-1)-1. Common difficulty: Students often forget the asymmetry in signed ranges (one more negative value than positive). Teaching remedy: Emphasize that zero takes up one of the positive 'slots', leaving unequal positive/negative ranges.",
      "level": 4,
      "learning_objectives": [
        "Calculate range limits for any bit width",
        "Explain asymmetry in signed integer ranges",
        "Apply range knowledge to prevent overflow in programs"
      ],
      "common_misconceptions": [
        {
          "misconception": "Expecting equal numbers of positive and negative values in signed types",
          "remedy": "Show number line diagrams emphasizing that zero 'uses up' a positive slot"
        },
        {
          "misconception": "Forgetting to subtract 1 from 2^n for maximum values",
          "remedy": "Emphasize that counting starts at 0, so n bits can represent 0 through 2^n-1"
        }
      ],
      "prerequisites": ["exponent calculation", "signed vs unsigned concept"],
      "assessment_strategies": ["range calculation problems", "overflow boundary testing"]
    },
    {
      "id": "CSCD210-D1-S1-C3-A3",
      "title": "Trace overflow errors in sample code",
      "name": "Trace overflow errors in sample code",
      "description": "Students analyze Java code examples to identify potential overflow conditions and predict the resulting incorrect behavior. Common difficulty: Students often focus on syntax rather than considering the mathematical limits of operations. Teaching remedy: Provide code examples with large number calculations and have students trace through step-by-step, checking against data type limits.",
      "level": 4,
      "learning_objectives": [
        "Identify overflow-prone operations in Java code",
        "Predict incorrect results from overflow conditions",
        "Suggest fixes for overflow-vulnerable code"
      ],
      "common_misconceptions": [
        {
          "misconception": "Assuming Java will automatically prevent overflow",
          "remedy": "Show concrete examples of Java int overflow, demonstrate silent failures"
        },
        {
          "misconception": "Thinking overflow only happens with huge numbers",
          "remedy": "Show how common operations like multiplication can quickly cause overflow"
        }
      ],
      "prerequisites": ["Java arithmetic operators", "data type limits knowledge"],
      "assessment_strategies": ["code analysis exercises", "debugging overflow scenarios"]
    },
    {
      "id": "CSCD210-D1-S2",
      "title": "Base Conversion Techniques",
      "name": "Base Conversion Techniques",
      "description": "Students master systematic methods for converting numbers between different bases (decimal, binary, hexadecimal). This skill is fundamental for understanding how computers represent and manipulate data internally, and for debugging low-level programming issues.",
      "level": 2,
      "learning_objectives": [
        "Convert between decimal, binary, and hexadecimal representations",
        "Understand why different bases are useful in computing",
        "Apply base conversion to debug program behavior"
      ],
      "pedagogical_approach": "Teach algorithmic methods rather than memorization, emphasize pattern recognition across different bases",
      "real_world_applications": [
        "Debugging memory addresses (hexadecimal)",
        "Understanding file permissions (octal)",
        "Color codes in web development (hexadecimal)"
      ]
    },
    {
      "id": "CSCD210-D1-S2-C1",
      "title": "Decimal to Binary",
      "name": "Decimal to Binary",
      "description": "Students learn the repeated division method to convert decimal numbers to binary representation. This algorithmic approach provides a systematic way to handle any size decimal number without memorizing conversion tables.",
      "level": 3,
      "learning_objectives": [
        "Apply repeated division algorithm systematically",
        "Verify conversions by converting back to decimal",
        "Handle both small and large decimal numbers"
      ],
      "pedagogical_notes": "Start with small numbers to build confidence, then progress to larger examples that require systematic approach"
    },
    {
      "id": "CSCD210-D1-S2-C1-A1",
      "title": "Manually convert positive integers to binary",
      "name": "Manually convert positive integers to binary",
      "description": "Students perform step-by-step conversion from decimal to binary using the division-by-2 method, collecting remainders to form the binary result. Common difficulty: Students often write the binary digits in the wrong order (reading remainders top-to-bottom instead of bottom-to-top). Teaching remedy: Emphasize that remainders must be read in reverse order of generation, use visual stacking to show correct reading direction.",
      "level": 4,
      "learning_objectives": [
        "Execute division-by-2 algorithm correctly",
        "Collect remainders in proper order for binary result",
        "Verify accuracy through reverse conversion"
      ],
      "common_misconceptions": [
        {
          "misconception": "Reading remainders in order of generation rather than reverse",
          "remedy": "Use visual aids showing remainders stacked vertically, emphasize bottom-to-top reading"
        },
        {
          "misconception": "Stopping division before reaching zero",
          "remedy": "Emphasize continuing division until quotient becomes zero, practice with examples"
        }
      ],
      "prerequisites": ["division with remainders", "understanding of binary representation"],
      "assessment_strategies": ["step-by-step conversion exercises", "error identification in student work"]
    },
    {
      "id": "CSCD210-D1-S2-C1-A2",
      "title": "Use repeated division for base changes",
      "name": "Use repeated division for base changes",
      "description": "Students generalize the division method to convert between any two bases (not just decimal to binary). They understand that dividing by the target base and collecting remainders works universally. Common difficulty: Students may struggle with division in non-decimal bases. Teaching remedy: Allow students to work in decimal for the arithmetic, converting only the final result.",
      "level": 4,
      "learning_objectives": [
        "Apply division method to any base conversion",
        "Understand why division-by-target-base works universally",
        "Convert between arbitrary bases (binary, octal, hexadecimal)"
      ],
      "common_misconceptions": [
        {
          "misconception": "Thinking different bases require completely different methods",
          "remedy": "Show that same algorithm works for all bases, only the divisor changes"
        },
        {
          "misconception": "Confusion about which base to use for arithmetic during conversion",
          "remedy": "Clarify that arithmetic can be done in familiar base, result interpreted in target base"
        }
      ],
      "prerequisites": ["decimal-to-binary conversion", "understanding of positional notation"],
      "assessment_strategies": ["multi-base conversion problems", "algorithm explanation exercises"]
    },
    {
      "id": "CSCD210-D1-S2-C1-A3",
      "title": "Verify conversions by reconverting",
      "name": "Verify conversions by reconverting",
      "description": "Students learn to check their conversion accuracy by performing the reverse operation and confirming they get back to the original number. This verification step builds confidence and catches errors. Common oversight: Students often skip verification step due to time pressure. Teaching remedy: Make verification a required step in all assignments, emphasize that professional programmers always verify their work.",
      "level": 4,
      "learning_objectives": [
        "Perform reverse conversions to verify accuracy",
        "Develop habits of self-checking mathematical work",
        "Identify and correct conversion errors systematically"
      ],
      "common_misconceptions": [
        {
          "misconception": "Viewing verification as optional or time-wasting",
          "remedy": "Emphasize professional practice, show how verification catches errors that would be costly later"
        },
        {
          "misconception": "Assuming verification is always straightforward",
          "remedy": "Show cases where verification reveals subtle errors, demonstrate debugging process"
        }
      ],
      "prerequisites": ["forward conversion skills", "reverse conversion methods"],
      "assessment_strategies": ["verification requirement in all problems", "error detection exercises"]
    },
    {
      "id": "CSCD210-D1-S2-C2",
      "title": "Binary to Hexadecimal",
      "name": "Binary to Hexadecimal",
      "description": "Students learn the direct grouping method to convert between binary and hexadecimal, understanding that each hex digit represents exactly 4 binary digits (a nibble). This shortcut method is essential for efficiently reading memory addresses and debugging low-level code.",
      "level": 3,
      "learning_objectives": [
        "Group binary digits into 4-bit chunks (nibbles)",
        "Convert each nibble directly to hexadecimal digit",
        "Understand why hexadecimal is convenient for binary representation"
      ],
      "pedagogical_approach": "Emphasize pattern recognition rather than arithmetic conversion, show practical applications in debugging and memory analysis"
    },
    {
      "id": "CSCD210-D1-S2-C2-A1",
      "title": "Group binary digits into nibbles",
      "name": "Group binary digits into nibbles",
      "description": "Students practice dividing binary numbers into 4-bit groups (nibbles), starting from the rightmost bit and padding with leading zeros if necessary. Common difficulty: Students sometimes group from left to right instead of right to left. Teaching remedy: Emphasize that grouping starts from the least significant bit (rightmost) to maintain positional value meaning.",
      "level": 4,
      "learning_objectives": [
        "Systematically group binary digits from right to left",
        "Add leading zeros when necessary for complete nibbles",
        "Understand why grouping preserves positional meaning"
      ],
      "common_misconceptions": [
        {
          "misconception": "Grouping binary digits from left to right",
          "remedy": "Show how left-to-right grouping can misalign positional values, practice with examples"
        },
        {
          "misconception": "Forgetting to pad with leading zeros",
          "remedy": "Emphasize that incomplete left nibbles need zero padding, provide practice problems"
        }
      ],
      "prerequisites": ["binary number understanding", "positional notation concepts"],
      "assessment_strategies": ["nibble grouping exercises", "padding practice problems"]
    },
    {
      "id": "CSCD210-D1-S2-C2-A2",
      "title": "Map 4-bit patterns to hex symbols",
      "name": "Map 4-bit patterns to hex symbols",
      "description": "Students memorize or reference the mapping between each 4-bit binary pattern (0000 through 1111) and corresponding hexadecimal symbols (0 through F). Common difficulty: Students often confuse hex digits A-F with their decimal values. Teaching remedy: Create memorable associations (A=10, B=11, etc.) and provide reference cards for practice.",
      "level": 4,
      "learning_objectives": [
        "Quickly identify hex symbols for any 4-bit pattern",
        "Understand that A-F represent values 10-15",
        "Use reference materials efficiently during conversion"
      ],
      "common_misconceptions": [
        {
          "misconception": "Treating hex digits A-F as having values beyond 15",
          "remedy": "Repeatedly emphasize that F represents 15, highest single-digit hex value"
        },
        {
          "misconception": "Confusing hex digits with alphabetic letters",
          "remedy": "Show hex in context of numeric values, practice with mixed problems"
        }
      ],
      "prerequisites": ["4-bit binary patterns", "hexadecimal digit system"],
      "assessment_strategies": ["pattern-to-hex mapping drills", "reference sheet usage practice"]
    },
    {
      "id": "CSCD210-D1-S2-C2-A3",
      "title": "Perform quick mental conversions",
      "name": "Perform quick mental conversions",
      "description": "Students develop fluency in binary-to-hexadecimal conversion through pattern recognition, aiming for immediate recognition of common nibble patterns without calculation. Common challenge: Students want to convert through decimal as intermediate step. Teaching remedy: Emphasize direct pattern matching, provide frequent practice with immediate feedback.",
      "level": 4,
      "learning_objectives": [
        "Recognize common binary-hex patterns immediately",
        "Convert without intermediate decimal calculations",
        "Build fluency through repetitive practice"
      ],
      "common_misconceptions": [
        {
          "misconception": "Always converting through decimal as intermediate step",
          "remedy": "Show efficiency of direct conversion, time practice exercises to encourage speed"
        },
        {
          "misconception": "Thinking speed comes before accuracy",
          "remedy": "Emphasize accuracy first, then build speed through pattern familiarity"
        }
      ],
      "prerequisites": ["binary-hex pattern knowledge", "nibble grouping skills"],
      "assessment_strategies": ["timed conversion exercises", "pattern recognition drills"]
    },
    {
      "id": "CSCD210-D1-S2-C3",
      "title": "Common Conversion Errors",
      "name": "Common Conversion Errors",
      "description": "Students learn to identify and avoid typical mistakes made during base conversions, developing systematic checking habits that prevent errors in real-world programming contexts. Understanding common pitfalls helps students become more reliable programmers.",
      "level": 3,
      "learning_objectives": [
        "Recognize patterns of common conversion mistakes",
        "Develop systematic verification habits",
        "Apply error prevention strategies in programming contexts"
      ],
      "pedagogical_approach": "Show actual student work examples with errors, have students identify and correct mistakes before learning prevention strategies"
    },
    {
      "id": "CSCD210-D1-S2-C3-A1",
      "title": "Avoid off-by-one mistakes in base changes",
      "name": "Avoid off-by-one mistakes in base changes",
      "description": "Students learn to prevent common off-by-one errors such as miscounting bit positions or using wrong ranges for data types. Common error: Starting bit position counts at 1 instead of 0. Teaching remedy: Consistently reinforce that computer science uses zero-based indexing, provide visual aids showing position labels.",
      "level": 4,
      "learning_objectives": [
        "Apply zero-based indexing consistently",
        "Double-check position counting in multi-step problems",
        "Recognize off-by-one patterns in own work"
      ],
      "common_misconceptions": [
        {
          "misconception": "Using 1-based indexing from mathematical background",
          "remedy": "Explicitly contrast math vs computer science conventions, provide labeled diagrams"
        },
        {
          "misconception": "Inconsistent indexing within same problem",
          "remedy": "Require students to explicitly state indexing convention at start of each problem"
        }
      ],
      "prerequisites": ["understanding of indexing conventions", "base conversion fundamentals"],
      "assessment_strategies": ["error identification exercises", "index checking requirements"]
    },
    {
      "id": "CSCD210-D1-S2-C3-A2",
      "title": "Handle leading zeros correctly",
      "name": "Handle leading zeros correctly",
      "description": "Students understand when leading zeros are significant (in fixed-width representations) versus when they can be omitted (in mathematical contexts). Common confusion: Students sometimes drop significant leading zeros or add unnecessary ones. Teaching remedy: Clearly distinguish between mathematical equivalence (where leading zeros don't matter) and computer representation (where they often do matter).",
      "level": 4,
      "learning_objectives": [
        "Determine when leading zeros are significant",
        "Preserve zeros in fixed-width representations",
        "Understand context-dependent zero handling"
      ],
      "common_misconceptions": [
        {
          "misconception": "Thinking leading zeros never matter",
          "remedy": "Show examples where leading zeros indicate data width or alignment requirements"
        },
        {
          "misconception": "Always including maximum possible leading zeros",
          "remedy": "Explain when brevity is acceptable vs when fixed width is required"
        }
      ],
      "prerequisites": ["fixed-width number representation", "mathematical notation"],
      "assessment_strategies": ["context-specific zero handling problems", "representation format exercises"]
    },
    {
      "id": "CSCD210-D1-S2-C3-A3",
      "title": "Detect when numbers mix base representations",
      "name": "Detect when numbers mix base representations",
      "description": "Students learn to identify and correct situations where they accidentally mix different base representations within the same calculation (e.g., treating a binary number as decimal). Common error: Seeing '101' and treating it as 'one hundred one' instead of recognizing it might be binary. Teaching remedy: Require explicit base notation (101₂, 101₁₀) and teach students to question ambiguous numbers.",
      "level": 4,
      "learning_objectives": [
        "Recognize ambiguous number representations",
        "Use explicit base notation consistently",
        "Question context when base is unclear"
      ],
      "common_misconceptions": [
        {
          "misconception": "Assuming numbers are always in decimal unless told otherwise",
          "remedy": "Provide problems where context clues indicate non-decimal bases, emphasize notation importance"
        },
        {
          "misconception": "Mixing bases within single calculation without realizing",
          "remedy": "Require base notation throughout multi-step problems, teach systematic checking"
        }
      ],
      "prerequisites": ["multiple base familiarity", "notation conventions"],
      "assessment_strategies": ["base detection exercises", "mixed-base error identification"]
    },
    {
      "id": "CSCD210-D1-S3",
      "title": "Character & Numeric Encoding",
      "name": "Character & Numeric Encoding",
      "description": "Mappings between characters, integers, and floating point layouts.",
      "level": 2
    },
    {
      "id": "CSCD210-D1-S3-C1",
      "title": "ASCII vs Unicode",
      "name": "ASCII vs Unicode",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D1-S3-C1-A1",
      "title": "Define code point for characters",
      "name": "Define code point for characters",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D1-S3-C1-A2",
      "title": "Explain how UTF-8 encodes characters",
      "name": "Explain how UTF-8 encodes characters",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D1-S3-C1-A3",
      "title": "Recognize escape sequences like \n and \t",
      "name": "Recognize escape sequences like \n and \t",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D1-S3-C2",
      "title": "Control Characters",
      "name": "Control Characters",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D1-S3-C2-A1",
      "title": "Differentiate newline and carriage return",
      "name": "Differentiate newline and carriage return",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D1-S3-C2-A2",
      "title": "Identify common non-printable codes",
      "name": "Identify common non-printable codes",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D1-S3-C2-A3",
      "title": "Use line endings as file delimiters",
      "name": "Use line endings as file delimiters",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D1-S3-C3",
      "title": "IEEE 754 Floating Point",
      "name": "IEEE 754 Floating Point",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D1-S3-C3-A1",
      "title": "Break down sign, exponent, mantissa fields",
      "name": "Break down sign, exponent, mantissa fields",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D1-S3-C3-A2",
      "title": "Predict precision loss in double calculations",
      "name": "Predict precision loss in double calculations",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D1-S3-C3-A3",
      "title": "Interpret NaN and Infinity values",
      "name": "Interpret NaN and Infinity values",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D2",
      "title": "Primitive Data Types & Expressions",
      "name": "Primitive Data Types & Expressions",
      "description": "Students master Java's primitive data types (int, double, boolean, char), variable declaration and initialization, type conversions, and mathematical expressions. This foundational domain bridges computer science theory with practical programming implementation, emphasizing both conceptual understanding and professional coding practices.",
      "level": 1,
      "learning_objectives": [
        "Declare and initialize variables using appropriate primitive types",
        "Perform type conversions and understand precision implications",
        "Apply mathematical operators and understand precedence rules",
        "Design meaningful variable names following Java conventions"
      ],
      "pedagogical_approach": "Connect abstract data type concepts to concrete Java implementations, emphasize debugging skills through type mismatch errors",
      "real_world_connections": [
        "Financial calculations requiring decimal precision",
        "Game development using different numeric ranges",
        "Data analysis with appropriate variable selection"
      ]
    },
    {
      "id": "CSCD210-D2-S1",
      "title": "Variable Declaration & Scope",
      "name": "Variable Declaration & Scope",
      "description": "Students learn to declare variables with appropriate data types and meaningful names, understanding where variables are accessible within Java programs. This section emphasizes professional naming conventions and scope rules that prevent common programming errors.",
      "level": 2,
      "learning_objectives": [
        "Declare variables using proper Java syntax and naming conventions",
        "Understand variable scope and lifetime within code blocks",
        "Initialize variables appropriately to avoid undefined behavior"
      ],
      "common_student_struggles": [
        "Forgetting to initialize variables before use",
        "Confusion about when variables go out of scope",
        "Using inappropriate data types for given problems"
      ],
      "pedagogical_tips": "Use visual diagrams showing scope boundaries, demonstrate scope errors that students can relate to"
    },
    {
      "id": "CSCD210-D2-S1-C1",
      "title": "Declare variables with meaningful identifiers",
      "name": "Declare variables with meaningful identifiers",
      "description": "Students learn to create variables with names that clearly communicate purpose and content, following Java naming conventions. This fundamental skill improves code readability and maintainability throughout professional software development.",
      "level": 3,
      "learning_objectives": [
        "Apply camelCase naming convention consistently",
        "Choose names that describe variable purpose and content",
        "Avoid misleading or abbreviated variable names"
      ],
      "pedagogical_approach": "Show side-by-side code examples with good vs poor variable names, emphasize long-term maintenance perspective"
    },
    {
      "id": "CSCD210-D2-S1-C1-A1",
      "title": "Choose descriptive names",
      "name": "Choose descriptive names",
      "description": "Students practice selecting variable names that clearly indicate the data being stored and its intended use within the program. Common misconception: Students often think shorter names are better for efficiency. Teaching remedy: Explain that modern compilers optimize regardless of name length, and readability is paramount for debugging and collaboration.",
      "level": 4,
      "learning_objectives": [
        "Select names that indicate data content and purpose",
        "Avoid single-letter variables except for loop counters",
        "Balance brevity with clarity in naming choices"
      ],
      "common_misconceptions": [
        {
          "misconception": "Believing shorter variable names improve program performance",
          "remedy": "Explain compiler optimization and emphasize that readability has no runtime cost"
        },
        {
          "misconception": "Using abbreviations that seem obvious but confuse others",
          "remedy": "Show examples of ambiguous abbreviations, emphasize collaborative programming perspective"
        }
      ],
      "prerequisites": ["basic understanding of data storage", "concept of program readability"],
      "assessment_strategies": ["variable naming improvement exercises", "code review activities"]
    },
    {
      "id": "CSCD210-D2-S1-C1-A2",
      "title": "Predict lifetime of local variables",
      "name": "Predict lifetime of local variables",
      "description": "Students understand that local variables exist only within the code block where they are declared, and are automatically destroyed when execution leaves that block. Common confusion: Students expect variables to retain values between method calls. Teaching remedy: Use visual diagrams showing stack frames and variable creation/destruction during program execution.",
      "level": 4,
      "learning_objectives": [
        "Identify scope boundaries using curly braces",
        "Predict when variables become inaccessible",
        "Understand automatic memory management for local variables"
      ],
      "common_misconceptions": [
        {
          "misconception": "Expecting local variables to retain values between method calls",
          "remedy": "Demonstrate variable recreation with each method invocation, show stack frame diagrams"
        },
        {
          "misconception": "Thinking variables declared in loops persist after loop completion",
          "remedy": "Show scope diagrams with nested blocks, demonstrate compilation errors for out-of-scope access"
        }
      ],
      "prerequisites": ["understanding of code blocks and curly braces", "basic method concept"],
      "assessment_strategies": ["scope prediction exercises", "debugging scope error problems"]
    },
    {
      "id": "CSCD210-D2-S1-C1-A3",
      "title": "Differentiate initialization from assignment",
      "name": "Differentiate initialization from assignment",
      "description": "Students distinguish between giving a variable its first value (initialization) and changing the value of an already-existing variable (assignment). Common confusion: Students may try to re-declare variables with different types. Teaching remedy: Emphasize that declaration happens once per scope, while assignment can happen multiple times to change the stored value.",
      "level": 4,
      "learning_objectives": [
        "Recognize initialization syntax during variable declaration",
        "Understand that assignment changes existing variable values",
        "Avoid redeclaring variables within the same scope"
      ],
      "common_misconceptions": [
        {
          "misconception": "Attempting to redeclare variables with different types in same scope",
          "remedy": "Show compiler errors for redeclaration, emphasize one declaration per scope rule"
        },
        {
          "misconception": "Thinking uninitialized variables automatically contain zero or null",
          "remedy": "Demonstrate compiler errors for uninitialized variable use, emphasize explicit initialization requirement"
        }
      ],
      "prerequisites": ["variable declaration syntax", "understanding of data types"],
      "assessment_strategies": ["initialization vs assignment identification exercises", "debugging uninitialized variable errors"]
    },
    {
      "id": "CSCD210-D2-S1-C2",
      "title": "Arithmetic & Logical Expressions",
      "name": "Arithmetic & Logical Expressions",
      "description": "Students construct and evaluate mathematical and logical expressions in Java, understanding operator precedence, type interactions, and the differences between integer and floating-point arithmetic. This section builds computational thinking skills essential for algorithm implementation.",
      "level": 3,
      "learning_objectives": [
        "Construct mathematical expressions using appropriate operators",
        "Understand operator precedence and association rules",
        "Distinguish between integer and floating-point arithmetic behavior",
        "Combine logical operators to create complex boolean expressions"
      ],
      "pedagogical_approach": "Use concrete examples from mathematics and real-world problems, emphasize hands-on experimentation with different data types"
    },
    {
      "id": "CSCD210-D2-S1-C2-A1",
      "title": "Trace integer division versus floating results",
      "name": "Trace integer division versus floating results",
      "description": "Students understand that division between two integers produces integer results (truncating decimal portions), while division involving floating-point numbers preserves decimal precision. Common misconception: Students expect all division to behave like mathematical division. Teaching remedy: Demonstrate side-by-side comparisons showing how 7/2 gives different results with integers versus doubles.",
      "level": 4,
      "learning_objectives": [
        "Predict results of integer division operations",
        "Understand when division truncates vs preserves decimals",
        "Choose appropriate data types for accurate division results"
      ],
      "common_misconceptions": [
        {
          "misconception": "Expecting integer division to always produce decimal results",
          "remedy": "Show concrete examples: 7/2 = 3 (integers) vs 7.0/2 = 3.5 (floating-point)"
        },
        {
          "misconception": "Confusion about when Java performs automatic type promotion",
          "remedy": "Demonstrate rules: integer operations stay integer unless one operand is floating-point"
        }
      ],
      "prerequisites": ["variable declaration with different numeric types", "basic arithmetic concepts"],
      "assessment_strategies": ["prediction exercises with mixed data types", "debugging arithmetic precision problems"]
    },
    {
      "id": "CSCD210-D2-S1-C2-A2",
      "title": "Construct boolean expressions with && and ||",
      "name": "Construct boolean expressions with && and ||",
      "description": "Students learn to combine multiple conditions using logical AND (&&) and OR (||) operators, understanding short-circuit evaluation behavior. Common difficulty: Students struggle with the logical structure of compound conditions. Teaching remedy: Use truth tables and real-world scenarios (like 'if it's raining AND I don't have an umbrella, then get wet') to make logical relationships concrete.",
      "level": 4,
      "learning_objectives": [
        "Combine multiple boolean conditions using logical operators",
        "Understand short-circuit evaluation and its performance implications",
        "Construct expressions that accurately represent complex logical requirements"
      ],
      "common_misconceptions": [
        {
          "misconception": "Confusion between & vs && and | vs || operators",
          "remedy": "Emphasize that && and || provide short-circuit behavior for boolean logic, while & and | are bitwise operators"
        },
        {
          "misconception": "Difficulty translating English logic to programming logic",
          "remedy": "Practice with real-world scenarios, break complex conditions into simpler parts"
        }
      ],
      "prerequisites": ["boolean data type understanding", "comparison operators"],
      "assessment_strategies": ["truth table completion exercises", "real-world logic translation problems"]
    },
    {
      "id": "CSCD210-D2-S1-C2-A3",
      "title": "Use modulo for cyclical patterns",
      "name": "Use modulo for cyclical patterns",
      "description": "Students apply the modulo operator (%) to create repeating patterns and determine remainders, essential for algorithms involving cycles, rotations, and periodic behavior. Common difficulty: Students often confuse modulo with division. Teaching remedy: Use visual examples like clock arithmetic (hour 15 becomes 3 PM using 15 % 12) and demonstrate how modulo 'wraps around' values.",
      "level": 4,
      "learning_objectives": [
        "Apply modulo operator to create cyclical behavior",
        "Use modulo for determining even/odd numbers",
        "Implement algorithms requiring remainder calculations"
      ],
      "common_misconceptions": [
        {
          "misconception": "Confusing modulo (remainder) with division (quotient)",
          "remedy": "Show side-by-side: 17/5 = 3 (quotient) while 17%5 = 2 (remainder)"
        },
        {
          "misconception": "Not understanding negative number behavior with modulo",
          "remedy": "Demonstrate that in Java, result sign matches dividend: -7%3 = -1, not 2"
        }
      ],
      "prerequisites": ["division and remainder concepts", "understanding of cyclical patterns"],
      "assessment_strategies": ["pattern generation exercises", "clock arithmetic problems", "even/odd detection tasks"]
    },
    {
      "id": "CSCD210-D2-S1-C3",
      "title": "Type Casting & Promotion",
      "name": "Type Casting & Promotion",
      "description": "Students learn when and how Java automatically converts between data types, and when explicit casting is required. Understanding type conversion prevents data loss and runtime errors while enabling flexible numeric computations.",
      "level": 3,
      "learning_objectives": [
        "Predict when Java performs automatic type conversions",
        "Apply explicit casting to prevent compilation errors",
        "Understand potential for data loss during narrowing conversions"
      ],
      "pedagogical_approach": "Use concrete examples showing data loss, emphasize compiler error messages as learning tools",
      "real_world_applications": ["Converting user input between different numeric formats", "Handling data from different sources with varying precision requirements"]
    },
    {
      "id": "CSCD210-D2-S1-C3-A1",
      "title": "Explain implicit widening conversions",
      "name": "Explain implicit widening conversions",
      "description": "Students understand that Java automatically converts smaller data types to larger ones (e.g., int to double) when no precision is lost. Common confusion: Students may not realize when widening occurs automatically. Teaching remedy: Show examples where int values become double in mixed arithmetic, emphasize that the conversion preserves all information safely.",
      "level": 4,
      "learning_objectives": [
        "Identify situations where automatic widening occurs",
        "Understand the safety guarantee of widening conversions",
        "Predict resulting data type in mixed arithmetic expressions"
      ],
      "common_misconceptions": [
        {
          "misconception": "Thinking all type conversions require explicit casting",
          "remedy": "Show examples of automatic int-to-double conversion in arithmetic expressions"
        },
        {
          "misconception": "Not understanding why some conversions are automatic while others aren't",
          "remedy": "Explain safety principle: automatic conversions never lose information"
        }
      ],
      "prerequisites": ["understanding of data type hierarchies", "concept of information preservation"],
      "assessment_strategies": ["type prediction exercises", "mixed arithmetic evaluation problems"]
    },
    {
      "id": "CSCD210-D2-S1-C3-A2",
      "title": "Perform explicit casts safely",
      "name": "Perform explicit casts safely",
      "description": "Students learn to use explicit casting syntax when converting larger types to smaller ones, understanding the risk of data loss. Common difficulty: Students forget that casting can truncate values. Teaching remedy: Demonstrate explicit examples showing how large double values lose decimal portions when cast to int, emphasize the programmer's responsibility to verify safe ranges.",
      "level": 4,
      "learning_objectives": [
        "Apply correct casting syntax for narrowing conversions",
        "Understand potential for data loss during casting",
        "Verify value ranges before performing risky casts"
      ],
      "common_misconceptions": [
        {
          "misconception": "Assuming casting always preserves original values",
          "remedy": "Show concrete examples: (int)3.7 becomes 3, (int)130.5 becomes 130"
        },
        {
          "misconception": "Using casting to 'fix' type errors without understanding implications",
          "remedy": "Emphasize that casting changes actual data, not just how compiler views it"
        }
      ],
      "prerequisites": ["explicit casting syntax", "understanding of data type capacities"],
      "assessment_strategies": ["casting prediction exercises", "data loss identification problems"]
    },
    {
      "id": "CSCD210-D2-S1-C3-A3",
      "title": "Avoid precision loss when mixing int and double",
      "name": "Avoid precision loss when mixing int and double",
      "description": "Students develop strategies to prevent unintended precision loss when combining integer and floating-point arithmetic. Common pitfall: Students divide integers first, then assign to double, losing decimal precision. Teaching remedy: Show the difference between (double)(7/2) which gives 3.0, and (double)7/2 which gives 3.5, emphasizing order of operations matters.",
      "level": 4,
      "learning_objectives": [
        "Recognize operations that may cause precision loss",
        "Apply parentheses and casting to preserve decimal precision",
        "Choose appropriate operation ordering for desired results"
      ],
      "common_misconceptions": [
        {
          "misconception": "Thinking casting the result fixes precision loss that already occurred",
          "remedy": "Show that (double)(7/2) = 3.0, not 3.5, because integer division happens first"
        },
        {
          "misconception": "Not understanding when integer division vs floating-point division occurs",
          "remedy": "Emphasize rule: if both operands are integers, result is integer regardless of destination variable type"
        }
      ],
      "prerequisites": ["arithmetic operator precedence", "type conversion rules"],
      "assessment_strategies": ["precision preservation exercises", "debugging mixed-type calculations"]
    },
    {
      "id": "CSCD210-D2-S2",
      "title": "Expression Evaluation",
      "name": "Expression Evaluation",
      "description": "Students master how Java evaluates complex expressions containing multiple operators, understanding precedence rules and evaluation strategies that ensure predictable program behavior. This foundational skill prevents logic errors and enables construction of sophisticated computational expressions.",
      "level": 2,
      "learning_objectives": [
        "Apply operator precedence rules to predict expression results",
        "Use parentheses strategically to ensure intended evaluation order",
        "Understand short-circuit evaluation in boolean expressions",
        "Debug expressions by tracing step-by-step evaluation"
      ],
      "pedagogical_approach": "Break complex expressions into evaluation steps, use visual tracing, emphasize that unclear expressions should use explicit parentheses"
    },
    {
      "id": "CSCD210-D2-S2-C1",
      "title": "Operator Precedence",
      "name": "Operator Precedence",
      "description": "Students learn the hierarchy of operator evaluation in Java, understanding that multiplication and division occur before addition and subtraction, and that assignment has the lowest precedence. Mastering precedence prevents logic errors and enables confident construction of mathematical expressions.",
      "level": 3,
      "learning_objectives": [
        "Memorize standard operator precedence hierarchy",
        "Trace expression evaluation following precedence rules",
        "Identify when parentheses are needed to override default precedence",
        "Write clear expressions that communicate intended evaluation order"
      ],
      "common_misconceptions": [
        {
          "misconception": "Assuming left-to-right evaluation for all operators",
          "remedy": "Show examples where precedence overrides left-to-right: 2 + 3 * 4 = 14, not 20"
        }
      ],
      "pedagogical_approach": "Use mathematical expressions students recognize from algebra, create evaluation trees for complex expressions"
    },
    {
      "id": "CSCD210-D2-S2-C1-A1",
      "title": "Apply PEMDAS to Java expressions",
      "name": "Apply PEMDAS to Java expressions",
      "description": "Students transfer their mathematical knowledge of order of operations (Parentheses, Exponents, Multiplication/Division, Addition/Subtraction) to Java programming context. Common confusion: Students may forget that programming follows the same mathematical rules they learned in algebra. Teaching remedy: Start with familiar math problems, then show equivalent Java expressions to reinforce that the rules are identical.",
      "level": 4,
      "learning_objectives": [
        "Apply mathematical order of operations to programming expressions",
        "Recognize that Java follows standard mathematical precedence",
        "Evaluate complex expressions step-by-step using PEMDAS"
      ],
      "common_misconceptions": [
        {
          "misconception": "Thinking programming has different precedence rules than mathematics",
          "remedy": "Emphasize that Java intentionally follows mathematical conventions for consistency"
        },
        {
          "misconception": "Forgetting that multiplication and division have equal precedence (left-to-right)",
          "remedy": "Show examples: 8/2*3 = 12 (not 8/6), emphasize left-to-right for equal precedence"
        }
      ],
      "prerequisites": ["basic arithmetic operators", "mathematical order of operations"],
      "assessment_strategies": ["step-by-step expression evaluation", "precedence prediction exercises"]
    },
    {
      "id": "CSCD210-D2-S2-C1-A2",
      "title": "Use parentheses to clarify intent",
      "name": "Use parentheses to clarify intent",
      "description": "Students learn that parentheses serve dual purposes: overriding default precedence when needed, and making complex expressions easier to understand even when precedence is correct. Common oversight: Students write expressions that are technically correct but difficult for humans to parse. Teaching remedy: Emphasize that code is written once but read many times, so clarity is more valuable than brevity.",
      "level": 4,
      "learning_objectives": [
        "Add parentheses to override default operator precedence",
        "Use parentheses to improve code readability",
        "Balance expression clarity with unnecessary complexity"
      ],
      "common_misconceptions": [
        {
          "misconception": "Believing extra parentheses hurt program performance",
          "remedy": "Explain that compilers optimize away unnecessary parentheses, readability has no runtime cost"
        },
        {
          "misconception": "Adding parentheses everywhere instead of learning precedence",
          "remedy": "Teach when parentheses add clarity vs when they create clutter"
        }
      ],
      "prerequisites": ["operator precedence rules", "concept of code readability"],
      "assessment_strategies": ["expression clarification exercises", "peer code review for readability"]
    },
    {
      "id": "CSCD210-D2-S2-C1-A3",
      "title": "Predict evaluation of mixed operators",
      "name": "Predict evaluation of mixed operators",
      "description": "Students develop skill in mentally tracing through expressions containing arithmetic, comparison, and logical operators with different precedence levels. Common difficulty: Students struggle when expressions mix different operator categories (arithmetic + comparison + logical). Teaching remedy: Create step-by-step evaluation tables showing how expressions like 'x > 5 && y < 10 * 2' are processed in phases.",
      "level": 4,
      "learning_objectives": [
        "Evaluate expressions mixing arithmetic and boolean operators",
        "Understand precedence relationships between operator categories",
        "Trace evaluation order in complex multi-operator expressions"
      ],
      "common_misconceptions": [
        {
          "misconception": "Not understanding that arithmetic operators execute before comparison operators",
          "remedy": "Show examples: x > 3 + 2 evaluates as x > (3 + 2), not (x > 3) + 2"
        },
        {
          "misconception": "Confusion when mixing comparison and logical operators",
          "remedy": "Emphasize that comparisons produce boolean values that logical operators then process"
        }
      ],
      "prerequisites": ["individual operator precedence rules", "understanding of boolean results from comparisons"],
      "assessment_strategies": ["multi-operator evaluation exercises", "debugging precedence-related logic errors"]
    },
    {
      "id": "CSCD210-D2-S2-C2",
      "title": "Boolean Evaluation",
      "name": "Boolean Evaluation",
      "description": "Students master how Java evaluates boolean expressions, particularly understanding short-circuit evaluation where the second part of an AND or OR expression may not execute if the first part determines the final result. This knowledge prevents runtime errors and enables efficient conditional logic.",
      "level": 3,
      "learning_objectives": [
        "Understand short-circuit evaluation behavior in && and || operations",
        "Write defensive code that prevents null pointer exceptions using short-circuiting",
        "Optimize boolean expressions for both clarity and performance",
        "Distinguish between short-circuit (&& ||) and non-short-circuit (& |) operators"
      ],
      "common_misconceptions": [
        {
          "misconception": "Expecting all parts of boolean expressions to always execute",
          "remedy": "Demonstrate with method calls that show when second conditions are skipped"
        }
      ],
      "pedagogical_approach": "Use examples with method calls to make evaluation order visible, emphasize practical safety benefits"
    },
    {
      "id": "CSCD210-D2-S2-C2-A1",
      "title": "Short-circuit AND and OR",
      "name": "Short-circuit AND and OR",
      "description": "Students learn that Java stops evaluating && expressions when the first part is false (since the whole expression must be false), and stops evaluating || expressions when the first part is true (since the whole expression must be true). Common application: Using this behavior to safely check for null before accessing object methods. Teaching example: 'if (obj != null && obj.getValue() > 0)' prevents null pointer exceptions.",
      "level": 4,
      "learning_objectives": [
        "Predict when second conditions will be skipped in logical expressions",
        "Use short-circuit evaluation to prevent runtime errors",
        "Understand performance implications of condition ordering"
      ],
      "common_misconceptions": [
        {
          "misconception": "Expecting all parts of && and || expressions to always execute",
          "remedy": "Show examples where method calls in second condition don't happen when first condition determines result"
        },
        {
          "misconception": "Not understanding the safety benefits for null checking",
          "remedy": "Demonstrate null pointer exception prevention using proper condition ordering"
        }
      ],
      "prerequisites": ["logical operators", "understanding of null values"],
      "assessment_strategies": ["short-circuit prediction exercises", "null-safe condition writing"]
    },
    {
      "id": "CSCD210-D2-S2-C2-A2",
      "title": "Negate complex conditions with De Morgan",
      "name": "Negate complex conditions with De Morgan",
      "description": "Students apply De Morgan's laws to transform complex boolean expressions, understanding that !(A && B) equals (!A || !B) and !(A || B) equals (!A && !B). Common difficulty: Students struggle with negating compound conditions correctly. Teaching remedy: Practice with concrete examples like '!(sunny && warm)' meaning 'not sunny OR not warm', showing that both conditions don't need to be false, just at least one.",
      "level": 4,
      "learning_objectives": [
        "Apply De Morgan's laws to negate compound boolean expressions",
        "Transform complex conditions into equivalent simpler forms",
        "Debug logical errors involving negated conditions"
      ],
      "common_misconceptions": [
        {
          "misconception": "Thinking !(A && B) equals (!A && !B) instead of (!A || !B)",
          "remedy": "Use real-world examples: 'not (rich AND tall)' means 'poor OR short', not 'poor AND short'"
        },
        {
          "misconception": "Applying negation incorrectly to comparison operators",
          "remedy": "Show that !(x > 5) becomes (x <= 5), not (x < 5)"
        }
      ],
      "prerequisites": ["logical operators", "boolean logic", "negation concept"],
      "assessment_strategies": ["condition negation exercises", "logical equivalence problems"]
    },
    {
      "id": "CSCD210-D2-S2-C2-A3",
      "title": "Compare strings using equals",
      "name": "Compare strings using equals",
      "description": "Students learn that string comparison in Java requires the .equals() method rather than == operator, understanding that == compares object references while .equals() compares content. Common error: Students use == for string comparison and get unpredictable results. Teaching remedy: Demonstrate that 'hello' == 'hello' may work due to string pooling, but new String('hello') == new String('hello') is always false, showing why .equals() is essential.",
      "level": 4,
      "learning_objectives": [
        "Use .equals() method for reliable string content comparison",
        "Understand the difference between reference equality (==) and content equality (.equals())",
        "Handle null strings safely using proper equals patterns"
      ],
      "common_misconceptions": [
        {
          "misconception": "Using == operator for string comparison assuming it compares content",
          "remedy": "Show examples where == fails: new String('test') == new String('test') returns false"
        },
        {
          "misconception": "Not understanding string pooling and when == might accidentally work",
          "remedy": "Explain string literals vs new String() objects, emphasize .equals() as consistent approach"
        }
      ],
      "prerequisites": ["String objects", "concept of object references", "null values"],
      "assessment_strategies": ["string comparison debugging exercises", "reference vs content equality identification"]
    },
    {
      "id": "CSCD210-D2-S2-C3",
      "title": "Type Promotion",
      "name": "Type Promotion",
      "description": "Students understand how Java automatically promotes smaller numeric types to larger ones during arithmetic operations, ensuring mathematical accuracy while sometimes producing unexpected results. This concept builds on type casting knowledge and prepares students for handling mixed-type calculations effectively.",
      "level": 3,
      "learning_objectives": [
        "Predict when automatic type promotion occurs in expressions",
        "Understand the promotion hierarchy: byte → short → int → long → float → double",
        "Handle mixed arithmetic operations correctly",
        "Recognize when explicit casting is needed vs automatic promotion"
      ],
      "common_misconceptions": [
        {
          "misconception": "Not realizing that byte and short operations promote to int",
          "remedy": "Show that byte + byte produces int result, requiring cast back to byte if needed"
        }
      ],
      "pedagogical_approach": "Use examples showing unexpected int results from byte/short arithmetic, emphasize safety of widening conversions"
    },
    {
      "id": "CSCD210-D2-S2-C3-A1",
      "title": "Observe automatic widening",
      "name": "Observe automatic widening",
      "description": "Students recognize situations where Java automatically converts values to wider data types, observing this behavior in mixed arithmetic and assignment operations. Common surprise: Students may not expect byte or short operations to become int automatically. Teaching remedy: Show practical examples where byte arithmetic requires casting back to byte, demonstrating Java's conservative approach to preventing overflow.",
      "level": 4,
      "learning_objectives": [
        "Identify operations that trigger automatic widening",
        "Understand that Java promotes to prevent data loss",
        "Recognize widening in assignment and method parameter contexts"
      ],
      "common_misconceptions": [
        {
          "misconception": "Expecting byte + byte to remain byte type",
          "remedy": "Demonstrate that Java promotes to int to prevent overflow, requires explicit cast back to byte"
        },
        {
          "misconception": "Not understanding when char participates in numeric promotion",
          "remedy": "Show that char arithmetic promotes to int, revealing underlying Unicode values"
        }
      ],
      "prerequisites": ["numeric data type hierarchy", "arithmetic operators"],
      "assessment_strategies": ["type prediction exercises", "widening identification in code samples"]
    },
    {
      "id": "CSCD210-D2-S2-C3-A2",
      "title": "Detect narrowing warnings",
      "name": "Detect narrowing warnings",
      "description": "Students learn to recognize and respond to compiler warnings about potential data loss when assigning larger types to smaller variables. Common oversight: Students may ignore warnings without understanding the implications. Teaching remedy: Show specific examples where int values like 300 cannot fit in byte variables (which hold only -128 to 127), resulting in unexpected wraparound behavior.",
      "level": 4,
      "learning_objectives": [
        "Interpret compiler warnings about possible lossy conversions",
        "Understand data range limitations for smaller integer types",
        "Use explicit casting when narrowing is intentional"
      ],
      "common_misconceptions": [
        {
          "misconception": "Ignoring compiler warnings about narrowing conversions",
          "remedy": "Show concrete examples of data loss: assigning 300 to byte results in 44 due to overflow"
        },
        {
          "misconception": "Not understanding value range limits for smaller types",
          "remedy": "Demonstrate byte range (-128 to 127) and short range (-32768 to 32767) with overflow examples"
        }
      ],
      "prerequisites": ["data type ranges", "concept of overflow"],
      "assessment_strategies": ["compiler warning interpretation exercises", "data loss prediction problems"]
    },
    {
      "id": "CSCD210-D2-S2-C3-A3",
      "title": "Combine ints and doubles correctly",
      "name": "Combine ints and doubles correctly",
      "description": "Students master the interaction between integer and floating-point arithmetic, understanding that any operation involving a double promotes the entire expression to double precision. Common pitfall: Students perform integer division first, losing precision before converting to double. Teaching remedy: Show the difference between (double)(7/2) which gives 3.0 and 7/2.0 which gives 3.5, emphasizing the importance of having at least one floating-point operand.",
      "level": 4,
      "learning_objectives": [
        "Predict result types when mixing int and double operations",
        "Preserve precision by ensuring floating-point context",
        "Understand promotion precedence in mixed expressions"
      ],
      "common_misconceptions": [
        {
          "misconception": "Expecting integer division to become floating-point when assigned to double variable",
          "remedy": "Show that int/int produces int result regardless of destination variable type"
        },
        {
          "misconception": "Not understanding that one floating-point operand promotes entire expression",
          "remedy": "Demonstrate: 7/2 = 3, but 7.0/2 = 3.5 and 7/2.0 = 3.5"
        }
      ],
      "prerequisites": ["integer vs floating-point division", "type promotion rules"],
      "assessment_strategies": ["mixed arithmetic prediction exercises", "precision preservation problems"]
    },
    {
      "id": "CSCD210-D2-S3",
      "title": "Assignment Operators",
      "name": "Assignment Operators",
      "description": "Students master efficient coding techniques using compound assignment operators (+=, -=, *=, /=) and increment/decrement operators (++, --), understanding both their convenience and potential pitfalls. These operators are fundamental for loop construction and accumulator patterns essential in algorithmic programming.",
      "level": 2,
      "learning_objectives": [
        "Use compound assignment operators for concise variable updates",
        "Understand pre-increment vs post-increment behavior and applications",
        "Apply increment operators correctly in loop contexts",
        "Recognize hidden type casting in compound assignments"
      ],
      "pedagogical_approach": "Start with simple examples, build to complex expressions, emphasize readability vs cleverness",
      "real_world_applications": ["Loop counters", "accumulator patterns", "efficient memory updates"]
    },
    {
      "id": "CSCD210-D2-S3-C1",
      "title": "Compound Assignment",
      "name": "Compound Assignment",
      "description": "Students learn to use compound assignment operators as shorthand for common variable update patterns, understanding that 'x += 5' is equivalent to 'x = x + 5' but more concise and sometimes more efficient. These operators are essential for accumulator patterns and reduce repetitive typing in mathematical computations.",
      "level": 3,
      "learning_objectives": [
        "Use +=, -=, *=, /=, %= operators correctly",
        "Understand equivalence between compound and expanded forms",
        "Apply compound assignments for accumulator patterns",
        "Recognize automatic type casting in compound operations"
      ],
      "common_misconceptions": [
        {
          "misconception": "Thinking compound operators are only cosmetic shortcuts",
          "remedy": "Explain that compound operators include implicit casting that expanded form doesn't"
        }
      ],
      "pedagogical_approach": "Show side-by-side expanded vs compound forms, emphasize accumulator use cases"
    },
    {
      "id": "CSCD210-D2-S3-C1-A1",
      "title": "Use +=, -=, *=, /= correctly",
      "name": "Use +=, -=, *=, /= correctly",
      "description": "Students practice applying compound assignment operators in various contexts, understanding proper syntax and behavior. Common error: Students may forget that the operator modifies the original variable. Teaching remedy: Emphasize that 'total += amount' both reads the current value of total and updates it with the new sum, contrasting with creating new variables.",
      "level": 4,
      "learning_objectives": [
        "Apply compound operators with correct syntax",
        "Understand that compound assignment modifies the original variable",
        "Use appropriate compound operator for each mathematical operation"
      ],
      "common_misconceptions": [
        {
          "misconception": "Thinking compound assignments create new variables",
          "remedy": "Emphasize that x += 5 modifies x itself, doesn't create a new variable"
        },
        {
          "misconception": "Using compound operators incorrectly with final variables",
          "remedy": "Show compiler errors when trying to modify final variables with compound operators"
        }
      ],
      "prerequisites": ["basic assignment operator", "arithmetic operators"],
      "assessment_strategies": ["compound operator substitution exercises", "accumulator pattern implementation"]
    },
    {
      "id": "CSCD210-D2-S3-C1-A2",
      "title": "Update counters efficiently",
      "name": "Update counters efficiently",
      "description": "Students apply compound assignment operators to implement counter and accumulator patterns that are fundamental in programming algorithms. Common pattern: Using += to build running totals and counters in data processing. Teaching example: Show how 'count += 1' and 'sum += currentValue' create essential accumulator patterns used throughout programming.",
      "level": 4,
      "learning_objectives": [
        "Implement counter patterns using compound assignment",
        "Build accumulator algorithms for sum, product, and counting",
        "Choose appropriate compound operators for different accumulation needs"
      ],
      "common_misconceptions": [
        {
          "misconception": "Not understanding accumulator patterns as fundamental algorithms",
          "remedy": "Show how accumulators are building blocks for loops, statistics, and data processing"
        },
        {
          "misconception": "Using compound operators incorrectly for conditional updates",
          "remedy": "Emphasize that compound operators always perform the operation, unlike conditional logic"
        }
      ],
      "prerequisites": ["loop concepts", "variable modification"],
      "assessment_strategies": ["accumulator implementation exercises", "counter pattern problems"]
    },
    {
      "id": "CSCD210-D2-S3-C1-A3",
      "title": "Avoid hidden casting with compound ops",
      "name": "Avoid hidden casting with compound ops",
      "description": "Students understand that compound assignment operators perform implicit casting that the expanded equivalent does not, which can mask type conversion issues. Common surprise: 'byte b = 10; b += 5;' compiles successfully, but 'byte b = 10; b = b + 5;' produces a compiler error. Teaching remedy: Explain that compound operators include automatic casting to the variable's type, which can hide potential overflow issues.",
      "level": 4,
      "learning_objectives": [
        "Understand implicit casting in compound assignment operations",
        "Recognize when compound operators mask type conversion issues",
        "Choose between compound and expanded forms based on type safety needs"
      ],
      "common_misconceptions": [
        {
          "misconception": "Expecting compound and expanded forms to have identical compiler behavior",
          "remedy": "Show that 'byte b += 5' compiles but 'byte b = b + 5' doesn't due to implicit int promotion"
        },
        {
          "misconception": "Not understanding that hidden casting can mask overflow",
          "remedy": "Demonstrate potential overflow when compound operators automatically cast back to smaller types"
        }
      ],
      "prerequisites": ["type casting concepts", "compiler error interpretation"],
      "assessment_strategies": ["compound vs expanded form comparison exercises", "type safety analysis problems"]
    },
    {
      "id": "CSCD210-D2-S3-C2",
      "title": "Increment & Decrement",
      "name": "Increment & Decrement",
      "description": "Students master the ++ and -- operators, understanding the crucial difference between pre-increment (++x) and post-increment (x++) forms. These operators are essential for loop construction and iterator patterns, but their subtlety in expressions requires careful understanding to prevent bugs.",
      "level": 3,
      "learning_objectives": [
        "Distinguish between pre-increment and post-increment behavior",
        "Use increment operators appropriately in loop contexts",
        "Understand side effects and evaluation order in expressions",
        "Avoid common pitfalls with increment operators in complex expressions"
      ],
      "common_misconceptions": [
        {
          "misconception": "Thinking ++ and -- only affect variables after statement completion",
          "remedy": "Show that pre-increment changes value before use, post-increment changes after use in same expression"
        }
      ],
      "pedagogical_approach": "Start with simple standalone statements, progress to complex expressions, emphasize loop usage patterns"
    },
    {
      "id": "CSCD210-D2-S3-C2-A1",
      "title": "Distinguish pre- vs post-increment",
      "name": "Distinguish pre- vs post-increment",
      "description": "Students learn that ++x increments x and returns the new value, while x++ increments x but returns the original value. Common confusion: Students may not understand when this difference matters. Teaching remedy: Use concrete examples like 'int a = 5; int b = ++a;' (b gets 6) versus 'int a = 5; int b = a++;' (b gets 5), showing how the timing of increment affects expression results.",
      "level": 4,
      "learning_objectives": [
        "Predict results of pre-increment vs post-increment in expressions",
        "Understand when increment timing affects program behavior",
        "Choose appropriate increment form based on intended logic"
      ],
      "common_misconceptions": [
        {
          "misconception": "Thinking pre and post increment always produce the same results",
          "remedy": "Show side-by-side examples where timing makes a difference in expression evaluation"
        },
        {
          "misconception": "Not understanding that both forms modify the variable",
          "remedy": "Emphasize that both ++x and x++ change x's value, only return value differs"
        }
      ],
      "prerequisites": ["assignment operations", "expression evaluation"],
      "assessment_strategies": ["increment timing prediction exercises", "expression result evaluation problems"]
    },
    {
      "id": "CSCD210-D2-S3-C2-A2",
      "title": "Use ++ in loops safely",
      "name": "Use ++ in loops safely",
      "description": "Students apply increment operators correctly in loop contexts, understanding that for simple loop counters, both ++i and i++ work identically in the increment section. Common best practice: Many programmers prefer ++i for consistency and slight efficiency benefits. Teaching emphasis: In loop increment sections, pre vs post doesn't matter for the loop behavior, but using increment operators correctly is essential for loop termination.",
      "level": 4,
      "learning_objectives": [
        "Use increment operators correctly in for loop increment sections",
        "Understand that pre/post distinction doesn't affect basic loop behavior",
        "Apply increment operators for array traversal and counting patterns"
      ],
      "common_misconceptions": [
        {
          "misconception": "Overthinking pre vs post increment choice in simple loop contexts",
          "remedy": "Show that for(int i=0; i<10; i++) and for(int i=0; i<10; ++i) behave identically"
        },
        {
          "misconception": "Using increment operators incorrectly in loop conditions",
          "remedy": "Emphasize that increment belongs in increment section, not condition section of loops"
        }
      ],
      "prerequisites": ["for loop structure", "increment operators"],
      "assessment_strategies": ["loop construction exercises", "increment placement identification"]
    },
    {
      "id": "CSCD210-D2-S3-C2-A3",
      "title": "Explain side effects in expressions",
      "name": "Explain side effects in expressions",
      "description": "Students understand that increment and decrement operators cause side effects (changing variable values) that can make expressions difficult to read and debug. Common pitfall: Using multiple increment operators on the same variable in one expression. Teaching remedy: Show examples like 'array[i++] = ++i' that produce undefined behavior, emphasizing that clarity should take precedence over cleverness.",
      "level": 4,
      "learning_objectives": [
        "Identify side effects caused by increment/decrement operators",
        "Understand why multiple side effects in one expression are problematic",
        "Write clear expressions that avoid confusing side effects"
      ],
      "common_misconceptions": [
        {
          "misconception": "Thinking complex expressions with multiple increments are more efficient",
          "remedy": "Show that unclear expressions cause bugs and maintenance problems that outweigh any minor efficiency gains"
        },
        {
          "misconception": "Not understanding that side effect timing can be undefined",
          "remedy": "Demonstrate expressions where evaluation order affects results unpredictably"
        }
      ],
      "prerequisites": ["increment/decrement operators", "expression evaluation"],
      "assessment_strategies": ["side effect identification exercises", "expression clarity evaluation"]
    },
    {
      "id": "CSCD210-D2-S3-C3",
      "title": "Assignment Evaluation Order",
      "name": "Assignment Evaluation Order",
      "description": "Students learn how Java evaluates complex assignment expressions, understanding right-to-left evaluation for assignment operators and the importance of writing clear, maintainable code rather than overly clever expressions. This knowledge prevents bugs and promotes professional code readability.",
      "level": 3,
      "learning_objectives": [
        "Understand right-to-left evaluation of assignment operators",
        "Predict results of chained assignments",
        "Prioritize code clarity over complex assignment tricks",
        "Recognize when assignment expressions become unmaintainable"
      ],
      "common_misconceptions": [
        {
          "misconception": "Assuming all operators evaluate left-to-right",
          "remedy": "Show that assignment is right-associative: a = b = c assigns c to b, then b to a"
        }
      ],
      "pedagogical_approach": "Start with simple chained assignments, emphasize readability principles over complexity"
    },
    {
      "id": "CSCD210-D2-S3-C3-A1",
      "title": "Predict result of chained assignments",
      "name": "Predict result of chained assignments",
      "description": "Students trace through chained assignment statements like 'a = b = c = 5', understanding that assignment operators evaluate right-to-left, so this assigns 5 to c, then c's value to b, then b's value to a. Common confusion: Students may expect left-to-right evaluation. Teaching remedy: Show step-by-step evaluation: first c=5, then b=(c=5), then a=(b=(c=5)), emphasizing the right-associative nature.",
      "level": 4,
      "learning_objectives": [
        "Trace evaluation order in chained assignment expressions",
        "Understand right-associative behavior of assignment operators",
        "Predict final variable values after chained assignments"
      ],
      "common_misconceptions": [
        {
          "misconception": "Expecting assignment to evaluate left-to-right like arithmetic",
          "remedy": "Show explicit parentheses: a = b = c becomes a = (b = c), not (a = b) = c"
        },
        {
          "misconception": "Not understanding that assignment expressions return values",
          "remedy": "Explain that assignment both changes the variable and returns the assigned value"
        }
      ],
      "prerequisites": ["assignment operator basics", "expression evaluation"],
      "assessment_strategies": ["chained assignment tracing exercises", "evaluation order prediction problems"]
    },
    {
      "id": "CSCD210-D2-S3-C3-A2",
      "title": "Avoid unreadable assignment tricks",
      "name": "Avoid unreadable assignment tricks",
      "description": "Students recognize that while complex assignment expressions are technically possible, they often reduce code readability and maintainability. Common temptation: Students may try to show cleverness with expressions like 'while((line = reader.readLine()) != null)'. Teaching guidance: Explain when such patterns are appropriate (like the common input loop pattern) versus when they should be avoided for clarity.",
      "level": 4,
      "learning_objectives": [
        "Recognize the difference between useful and unnecessarily complex assignment patterns",
        "Balance code conciseness with readability",
        "Understand when assignment in expressions is conventional vs confusing"
      ],
      "common_misconceptions": [
        {
          "misconception": "Believing complex expressions always demonstrate programming skill",
          "remedy": "Emphasize that professional code prioritizes maintainability and team understanding"
        },
        {
          "misconception": "Not understanding conventional patterns vs unnecessary complexity",
          "remedy": "Show examples of accepted patterns (like input loops) versus unnecessarily complex assignments"
        }
      ],
      "prerequisites": ["assignment operators", "code readability principles"],
      "assessment_strategies": ["code clarity evaluation exercises", "refactoring complex assignments for readability"]
    },
    {
      "id": "CSCD210-D2-S3-C3-A3",
      "title": "Place side effects intentionally",
      "name": "Place side effects intentionally",
      "description": "Students learn to use assignment expressions deliberately in appropriate contexts while avoiding accidental side effects that make code unpredictable. Common appropriate use: Assignment in loop conditions for input processing. Teaching principle: Side effects should be intentional, documented, and follow established patterns rather than being clever shortcuts that confuse readers.",
      "level": 4,
      "learning_objectives": [
        "Identify when assignment expressions serve legitimate purposes",
        "Avoid accidental side effects in complex expressions",
        "Document intentional side effects for code maintainability"
      ],
      "common_misconceptions": [
        {
          "misconception": "Using assignment expressions everywhere to reduce line count",
          "remedy": "Show that fewer lines doesn't mean better code if readability suffers"
        },
        {
          "misconception": "Not understanding that side effects can make debugging difficult",
          "remedy": "Demonstrate how assignment in expressions can hide the source of variable changes"
        }
      ],
      "prerequisites": ["side effects understanding", "professional coding standards"],
      "assessment_strategies": ["intentional vs accidental side effect identification", "code review for appropriate assignment usage"]
    },
    {
      "id": "CSCD210-D3",
      "title": "Control Structures",
      "name": "Control Structures",
      "description": "Students master the fundamental mechanisms that control program execution flow, including conditional statements (if/else, switch) and repetition structures (while, for, do-while loops). These constructs transform linear programs into dynamic, decision-making applications that can respond to user input and process varying amounts of data efficiently.",
      "level": 1,
      "learning_objectives": [
        "Implement conditional logic using if/else statements and boolean expressions",
        "Design and construct all three types of loops for different iteration scenarios",
        "Apply control structures to solve real-world programming problems",
        "Understand when to use each control structure for optimal code clarity and efficiency"
      ],
      "pedagogical_approach": "Start with simple decisions, build to complex nested structures, emphasize problem-solving patterns",
      "real_world_applications": ["User input validation", "data processing workflows", "game logic", "business rule implementation"]
    },
    {
      "id": "CSCD210-D3-S1",
      "title": "Conditional Logic",
      "name": "Conditional Logic",
      "description": "Students learn to implement decision-making in programs using if/else statements, boolean expressions, and logical operators. This foundational skill enables programs to respond differently based on user input, data values, or calculated conditions, forming the basis for interactive and intelligent software behavior.",
      "level": 2,
      "learning_objectives": [
        "Construct conditional statements using proper if/else syntax",
        "Combine multiple conditions using logical operators (&&, ||, !)",
        "Design nested decision structures for complex logic requirements",
        "Apply conditional logic to validate input and implement business rules"
      ],
      "pedagogical_approach": "Begin with simple two-way decisions, progress to multi-way structures, emphasize real-world decision scenarios",
      "common_misconceptions": [
        {
          "misconception": "Using assignment (=) instead of comparison (==) in conditions",
          "remedy": "Emphasize the difference between assignment and equality testing"
        }
      ]
    },
    {
      "id": "CSCD210-D3-S1-C1",
      "title": "Combine Relational Operators",
      "name": "Combine Relational Operators",
      "description": "Students master the use of comparison operators (>, <, >=, <=, ==, !=) and learn to combine them with logical operators to create sophisticated conditional expressions. This skill is essential for input validation, range checking, and implementing complex business logic in programs.",
      "level": 3,
      "learning_objectives": [
        "Use all six relational operators correctly in conditional expressions",
        "Chain multiple comparisons using logical AND (&&) and OR (||)",
        "Apply appropriate comparison operators for range and boundary checking",
        "Write readable compound conditions with proper parentheses"
      ],
      "common_misconceptions": [
        {
          "misconception": "Confusing assignment (=) with equality (==) in conditions",
          "remedy": "Practice with concrete examples showing the difference between setting and testing values"
        },
        {
          "misconception": "Misunderstanding boundary conditions with >= vs >",
          "remedy": "Use number line examples to clarify inclusive vs exclusive boundaries"
        }
      ],
      "pedagogical_approach": "Start with single comparisons, build to compound conditions, use real-world scenarios like age verification or grade boundaries"
    },
    {
      "id": "CSCD210-D3-S1-C1-A1",
      "title": "Use >, <, >=, <= appropriately",
      "name": "Use >, <, >=, <= appropriately",
      "description": "Students learn to choose the correct relational operator based on whether boundaries should be inclusive or exclusive. Common confusion: Students may not understand when to use >= versus > for boundary conditions. Teaching remedy: Use concrete examples like 'age >= 18 for voting' (inclusive) versus 'score > 90 for an A+' (exclusive), helping students understand the logical meaning behind boundary decisions.",
      "level": 4,
      "learning_objectives": [
        "Choose appropriate operators for inclusive vs exclusive boundaries",
        "Understand the logical meaning of each relational operator",
        "Apply correct operators for range checking and validation"
      ],
      "common_misconceptions": [
        {
          "misconception": "Not understanding the difference between >= and > for boundary conditions",
          "remedy": "Use number line visualizations and real-world examples like age requirements or grade boundaries"
        },
        {
          "misconception": "Randomly choosing operators without considering the logical requirement",
          "remedy": "Practice with specific scenarios that clearly define whether boundaries are inclusive or exclusive"
        }
      ],
      "prerequisites": ["boolean expressions", "concept of mathematical inequalities"],
      "assessment_strategies": ["boundary condition identification exercises", "real-world validation scenarios"]
    },
    {
      "id": "CSCD210-D3-S1-C1-A2",
      "title": "Chain comparisons with &&",
      "name": "Chain comparisons with &&",
      "description": "Students learn to combine multiple comparison expressions using the logical AND operator to create range checks and compound conditions. Common pattern: Checking if a value falls within a specific range using expressions like 'age >= 18 && age <= 65'. Teaching emphasis: Show how && requires ALL conditions to be true, making it perfect for defining valid ranges or ensuring multiple requirements are met simultaneously.",
      "level": 4,
      "learning_objectives": [
        "Combine multiple comparisons using logical AND (&&)",
        "Create range checking conditions for input validation",
        "Understand that && requires all conditions to be true"
      ],
      "common_misconceptions": [
        {
          "misconception": "Trying to write range checks like '18 <= age <= 65' which doesn't work in Java",
          "remedy": "Show that range checks must be written as 'age >= 18 && age <= 65' using explicit comparison for each boundary"
        },
        {
          "misconception": "Confusing when to use && versus || for compound conditions",
          "remedy": "Emphasize that && means 'both conditions must be true' while || means 'at least one condition must be true'"
        }
      ],
      "prerequisites": ["individual relational operators", "logical AND concept"],
      "assessment_strategies": ["range validation implementation", "compound condition truth table exercises"]
    },
    {
      "id": "CSCD210-D3-S1-C1-A3",
      "title": "Readability through parentheses",
      "name": "Readability through parentheses",
      "description": "Students learn to use parentheses strategically to make complex boolean expressions clear and unambiguous, even when operator precedence rules would produce the same result. Common challenge: Complex expressions mixing &&, ||, and ! operators can be difficult to read. Teaching principle: Parentheses cost nothing at runtime but greatly improve code maintainability by making the programmer's intent explicit to human readers.",
      "level": 4,
      "learning_objectives": [
        "Use parentheses to clarify complex boolean expressions",
        "Group related conditions logically for better readability",
        "Balance operator precedence knowledge with explicit clarity"
      ],
      "common_misconceptions": [
        {
          "misconception": "Believing that unnecessary parentheses hurt program performance",
          "remedy": "Explain that compilers optimize away extra parentheses, so clarity has no runtime cost"
        },
        {
          "misconception": "Either avoiding parentheses completely or using them excessively",
          "remedy": "Show examples where parentheses add meaningful clarity versus where they create visual clutter"
        }
      ],
      "prerequisites": ["boolean operator precedence", "complex boolean expressions"],
      "assessment_strategies": ["expression clarity improvement exercises", "peer code review for readability"]
    },
    {
      "id": "CSCD210-D3-S1-C2",
      "title": "Nested if/else",
      "name": "Nested if/else",
      "description": "Students master the construction of nested conditional statements to handle complex, multi-level decision scenarios. This advanced technique allows programs to implement sophisticated logic trees where decisions depend on the results of previous decisions, essential for real-world applications with complex business rules.",
      "level": 3,
      "learning_objectives": [
        "Structure multi-level decision trees using nested if/else statements",
        "Choose between nested if/else and if/else-if chains based on logic requirements",
        "Implement proper indentation and bracket placement for code readability",
        "Design default cases using final else clauses"
      ],
      "common_misconceptions": [
        {
          "misconception": "Creating unnecessarily deep nesting when simpler alternatives exist",
          "remedy": "Show when to use if/else-if chains versus true nesting based on the decision logic"
        },
        {
          "misconception": "Forgetting to handle all possible cases in nested structures",
          "remedy": "Emphasize importance of else clauses and systematic case analysis"
        }
      ],
      "pedagogical_approach": "Start with two-level nesting, progress to more complex structures, emphasize code organization and readability"
    },
    {
      "id": "CSCD210-D3-S1-C2-A1",
      "title": "Structure multi-way decisions",
      "name": "Structure multi-way decisions",
      "description": "Students learn to organize complex decision logic using either nested if/else statements or if/else-if chains, choosing the most appropriate structure based on the relationship between conditions. Common decision: Use nesting when decisions are truly hierarchical (like checking age first, then checking income), but use if/else-if chains when testing mutually exclusive categories (like letter grades A, B, C, D, F).",
      "level": 4,
      "learning_objectives": [
        "Choose between nested if/else and if/else-if chains based on decision logic",
        "Structure hierarchical decisions using appropriate nesting levels",
        "Organize mutually exclusive choices using if/else-if patterns"
      ],
      "common_misconceptions": [
        {
          "misconception": "Always using nesting when if/else-if chains would be clearer",
          "remedy": "Show examples where flat if/else-if structure is more appropriate for mutually exclusive options"
        },
        {
          "misconception": "Not understanding when decisions are truly hierarchical versus independent",
          "remedy": "Use decision trees and flowcharts to visualize the logical relationship between conditions"
        }
      ],
      "prerequisites": ["basic if/else statements", "logical decision analysis"],
      "assessment_strategies": ["decision structure design exercises", "logic flow diagram creation"]
    },
    {
      "id": "CSCD210-D3-S1-C2-A2",
      "title": "Guard against ladder complexity",
      "name": "Guard against ladder complexity",
      "description": "Students recognize when nested if/else structures become too complex and learn to refactor them for better readability and maintainability. Common problem: 'Arrow code' where deep nesting creates a ladder-like appearance that's difficult to follow. Teaching solution: Show techniques like early returns, guard clauses, and restructuring logic to reduce nesting depth while preserving the same decision-making behavior.",
      "level": 4,
      "learning_objectives": [
        "Identify when nesting becomes too complex for maintainability",
        "Apply refactoring techniques to reduce nesting depth",
        "Use guard clauses and early returns to simplify control flow"
      ],
      "common_misconceptions": [
        {
          "misconception": "Thinking deeper nesting always means more sophisticated programming",
          "remedy": "Show that professional code prioritizes readability and maintainability over clever complexity"
        },
        {
          "misconception": "Not recognizing when logic can be simplified or restructured",
          "remedy": "Practice with refactoring exercises that maintain the same behavior while improving structure"
        }
      ],
      "prerequisites": ["nested control structures", "code refactoring concepts"],
      "assessment_strategies": ["code complexity identification exercises", "nesting refactoring problems"]
    },
    {
      "id": "CSCD210-D3-S1-C2-A3",
      "title": "Default cases with else",
      "name": "Default cases with else",
      "description": "Students learn the importance of providing else clauses to handle unexpected or default cases in conditional logic, ensuring that programs behave predictably in all scenarios. Common oversight: Students may forget that not all possible input values are explicitly handled by their if conditions. Teaching emphasis: Final else clauses serve as safety nets that prevent programs from silently ignoring unexpected conditions.",
      "level": 4,
      "learning_objectives": [
        "Include appropriate else clauses to handle all possible cases",
        "Design meaningful default behaviors for unexpected conditions",
        "Ensure complete case coverage in conditional logic"
      ],
      "common_misconceptions": [
        {
          "misconception": "Assuming that if/else-if chains will always match one of the explicit conditions",
          "remedy": "Show examples where user input or data doesn't match any expected case"
        },
        {
          "misconception": "Using empty else blocks without providing meaningful default behavior",
          "remedy": "Emphasize that else clauses should handle unexpected cases gracefully, not just exist for syntax"
        }
      ],
      "prerequisites": ["if/else statement structure", "comprehensive case analysis"],
      "assessment_strategies": ["case coverage analysis exercises", "default behavior design problems"]
    },
    {
      "id": "CSCD210-D3-S1-C3",
      "title": "De Morgan Simplification",
      "name": "De Morgan Simplification",
      "description": "Students apply De Morgan's laws to simplify complex boolean expressions by transforming negated compound conditions into logically equivalent but more readable forms. This mathematical principle helps students write cleaner conditional logic and better understand the relationship between AND/OR operations when negation is involved.",
      "level": 3,
      "learning_objectives": [
        "Apply De Morgan's laws to transform !(a && b) into !a || !b and vice versa",
        "Simplify complex negated boolean expressions for improved readability",
        "Verify logical equivalence using truth tables and testing",
        "Choose between equivalent expressions based on code clarity"
      ],
      "common_misconceptions": [
        {
          "misconception": "Thinking that negating both sides of an expression is equivalent to negating the whole expression",
          "remedy": "Show concrete examples where !(a && b) is not the same as !a && !b"
        },
        {
          "misconception": "Applying De Morgan's laws incorrectly by not changing the operator",
          "remedy": "Emphasize that both the variables AND the operator must change: && becomes ||, || becomes &&"
        }
      ],
      "prerequisites": ["boolean logic", "logical operators", "negation"],
      "assessment_strategies": ["expression transformation exercises", "truth table verification", "code readability comparisons"],
      "pedagogical_approach": "Start with simple examples, use truth tables to verify equivalence, progress to practical code scenarios"
    },
    {
      "id": "CSCD210-D3-S1-C3-A1",
      "title": "Transform !(a && b) into !a || !b",
      "name": "Transform !(a && b) into !a || !b",
      "description": "Students master the fundamental De Morgan transformation where a negated AND expression becomes an OR of negated terms. Critical understanding: When you negate a compound AND condition, each individual condition becomes negated AND the operator changes from && to ||. Real example: !(age >= 18 && hasLicense) becomes (age < 18 || !hasLicense) - meaning 'either under 18 OR doesn't have license'.",
      "level": 4,
      "learning_objectives": [
        "Apply the !(a && b) = !a || !b transformation correctly",
        "Recognize when this transformation improves code readability",
        "Understand the logical meaning of the transformed expression"
      ],
      "common_misconceptions": [
        {
          "misconception": "Forgetting to change the && operator to || when applying the transformation",
          "remedy": "Emphasize that BOTH the negation AND the operator must change"
        },
        {
          "misconception": "Incorrectly transforming !(a && b) to !a && !b",
          "remedy": "Use truth tables to show these expressions are not equivalent"
        }
      ],
      "prerequisites": ["logical AND operations", "negation operator", "boolean logic"],
      "assessment_strategies": ["step-by-step transformation exercises", "truth table verification"]
    },
    {
      "id": "CSCD210-D3-S1-C3-A2",
      "title": "Reduce complex negations",
      "name": "Reduce complex negations",
      "description": "Students learn to simplify deeply nested or multiple negations in boolean expressions to improve code clarity and reduce logical errors. Common scenario: Expressions like !(!(a || b) && c) can be systematically reduced using De Morgan's laws and double negation elimination. Teaching emphasis: Complex negations are error-prone and hard to debug, so simplification is both a clarity and correctness issue.",
      "level": 4,
      "learning_objectives": [
        "Identify opportunities to reduce complex negations for clarity",
        "Apply De Morgan's laws iteratively to simplify nested expressions",
        "Eliminate double negations using the !!a = a rule"
      ],
      "common_misconceptions": [
        {
          "misconception": "Attempting to simplify complex expressions without systematic step-by-step approach",
          "remedy": "Teach methodical application of rules: work from inside parentheses outward"
        },
        {
          "misconception": "Not recognizing that complex negations often indicate poorly designed logic",
          "remedy": "Show how restructuring the original logic can eliminate need for complex negations"
        }
      ],
      "prerequisites": ["De Morgan's laws", "operator precedence", "boolean expression evaluation"],
      "assessment_strategies": ["step-by-step simplification exercises", "code refactoring for clarity"]
    },
    {
      "id": "CSCD210-D3-S1-C3-A3",
      "title": "Verify equivalence with truth tables",
      "name": "Verify equivalence with truth tables",
      "description": "Students use truth tables as a systematic method to verify that De Morgan transformations and other boolean simplifications produce logically equivalent expressions. This verification technique builds confidence in algebraic manipulations and provides a concrete way to check work when simplifying complex boolean logic.",
      "level": 4,
      "learning_objectives": [
        "Construct truth tables to verify boolean expression equivalence",
        "Compare original and simplified expressions systematically",
        "Use truth table verification to build confidence in algebraic transformations"
      ],
      "common_misconceptions": [
        {
          "misconception": "Trusting algebraic manipulations without verification",
          "remedy": "Emphasize that truth tables provide concrete proof of logical equivalence"
        },
        {
          "misconception": "Thinking that truth tables are only for simple expressions",
          "remedy": "Show how systematic table construction works even for complex nested expressions"
        }
      ],
      "prerequisites": ["truth table construction", "boolean operators", "logical equivalence"],
      "assessment_strategies": ["truth table construction exercises", "equivalence verification problems"]
    },
    {
      "id": "CSCD210-D3-S2",
      "title": "Looping Constructs",
      "name": "Looping Constructs",
      "description": "Students master the fundamental programming concept of repetition through for, while, and do-while loops, understanding when to choose each type based on the problem requirements. This section emphasizes proper loop design including initialization, condition testing, and update mechanisms, while highlighting common pitfalls like infinite loops and off-by-one errors.",
      "level": 2,
      "learning_objectives": [
        "Choose appropriate loop types (for, while, do-while) based on problem characteristics",
        "Design proper loop initialization, condition, and update patterns",
        "Implement sentinel-controlled and counter-controlled loop patterns",
        "Prevent infinite loops and off-by-one errors through careful design"
      ],
      "common_misconceptions": [
        {
          "misconception": "Always defaulting to for loops regardless of the problem type",
          "remedy": "Show specific scenarios where while or do-while loops are more natural and readable"
        },
        {
          "misconception": "Not understanding the relationship between loop conditions and termination",
          "remedy": "Emphasize that loop conditions specify when to CONTINUE, not when to STOP"
        }
      ],
      "prerequisites": ["conditional logic", "variable assignment", "boolean expressions"],
      "assessment_strategies": ["loop type selection exercises", "trace table completion", "infinite loop debugging"],
      "pedagogical_approach": "Start with simple counting loops, progress to data processing patterns, emphasize loop design methodology",
      "real_world_applications": ["data processing", "input validation", "game loops", "statistical calculations"]
    },
    {
      "id": "CSCD210-D3-S2-C1",
      "title": "Sentinel-Controlled Loops",
      "name": "Sentinel-Controlled Loops",
      "description": "Students learn to design loops that continue processing input until a special 'sentinel' value signals termination, a fundamental pattern for handling variable amounts of data. This technique is essential for programs that process user input, file data, or any scenario where the number of iterations isn't known in advance.",
      "level": 3,
      "learning_objectives": [
        "Design appropriate sentinel values that won't conflict with valid data",
        "Implement priming read and loop update patterns correctly",
        "Handle sentinel detection without processing the sentinel as data",
        "Choose between while and do-while loops for sentinel-controlled scenarios"
      ],
      "common_misconceptions": [
        {
          "misconception": "Processing the sentinel value as if it were regular data",
          "remedy": "Emphasize checking for sentinel BEFORE processing each input value"
        },
        {
          "misconception": "Choosing sentinel values that conflict with valid input ranges",
          "remedy": "Show examples of poor sentinel choices and their consequences"
        }
      ],
      "prerequisites": ["while loops", "input/output operations", "conditional logic"],
      "assessment_strategies": ["sentinel value selection exercises", "input processing implementations"],
      "pedagogical_approach": "Start with simple examples like -1 to end positive numbers, progress to more complex data scenarios"
    },
    {
      "id": "CSCD210-D3-S2-C1-A1",
      "title": "Choose sentinel value",
      "name": "Choose sentinel value",
      "description": "Students learn to select appropriate sentinel values that clearly distinguish termination signals from valid data, avoiding conflicts that could cause premature loop termination or processing errors. Key principle: Choose sentinels outside the valid data range or use special strings/characters that users would never enter as legitimate input.",
      "level": 4,
      "learning_objectives": [
        "Select sentinel values that don't conflict with valid input ranges",
        "Understand the importance of communicating sentinel values clearly to users",
        "Choose sentinels that are easy for users to type and remember"
      ],
      "common_misconceptions": [
        {
          "misconception": "Using sentinel values that overlap with valid data ranges",
          "remedy": "Show concrete examples where poor sentinel choice causes incorrect program behavior"
        },
        {
          "misconception": "Assuming users will never accidentally enter the sentinel value",
          "remedy": "Discuss robust input validation and confirmation strategies"
        }
      ],
      "prerequisites": ["data type ranges", "user interface design", "input validation"],
      "assessment_strategies": ["sentinel selection justification exercises", "user experience evaluation"]
    },
    {
      "id": "CSCD210-D3-S2-C1-A2",
      "title": "Update loop variables correctly",
      "name": "Update loop variables correctly",
      "description": "Students master the critical pattern of updating loop control variables to ensure progress toward termination, particularly the 'priming read' technique where input is read both before the loop and at the end of each iteration. Common error: Forgetting the update step, which leads to infinite loops when the loop condition never changes.",
      "level": 4,
      "learning_objectives": [
        "Implement the priming read pattern for input-controlled loops",
        "Ensure loop variables are updated in every iteration path",
        "Prevent infinite loops through proper variable modification"
      ],
      "common_misconceptions": [
        {
          "misconception": "Forgetting to read new input at the end of each loop iteration",
          "remedy": "Emphasize that without updates, loop conditions never change, causing infinite loops"
        },
        {
          "misconception": "Updating loop variables in the wrong location within the loop body",
          "remedy": "Show how variable update placement affects when sentinel detection occurs"
        }
      ],
      "prerequisites": ["while loop structure", "variable assignment", "input operations"],
      "assessment_strategies": ["loop trace exercises", "infinite loop debugging activities"]
    },
    {
      "id": "CSCD210-D3-S2-C1-A3",
      "title": "Terminate on sentinel detection",
      "name": "Terminate on sentinel detection",
      "description": "Students understand the precise logic for detecting sentinel values and terminating loops without processing the sentinel as regular data. Critical insight: The loop condition should test for non-sentinel values (continue while NOT sentinel), and sentinel detection should immediately trigger loop exit without any data processing on that value.",
      "level": 4,
      "learning_objectives": [
        "Write loop conditions that properly test for sentinel values",
        "Ensure sentinel values are not processed as regular data",
        "Implement clean loop termination when sentinels are detected"
      ],
      "common_misconceptions": [
        {
          "misconception": "Testing for sentinel values inside the loop body instead of in the loop condition",
          "remedy": "Show how this approach can lead to processing sentinel values as data"
        },
        {
          "misconception": "Using break statements unnecessarily when proper loop conditions would suffice",
          "remedy": "Demonstrate clean loop design using appropriate while conditions"
        }
      ],
      "prerequisites": ["loop conditions", "boolean logic", "sentinel concepts"],
      "assessment_strategies": ["sentinel detection implementation exercises", "loop logic verification problems"]
    },
    {
      "id": "CSCD210-D3-S2-C2",
      "title": "Off-by-One Prevention",
      "name": "Off-by-One Prevention",
      "description": "Students learn to identify and prevent off-by-one errors, one of the most common and subtle bugs in programming that occurs when loops execute one too many or one too few times. This section emphasizes careful analysis of loop boundaries, proper use of comparison operators, and systematic testing of edge cases.",
      "level": 3,
      "learning_objectives": [
        "Identify potential off-by-one errors in loop design",
        "Choose appropriate comparison operators (< vs <=) based on loop requirements",
        "Test boundary conditions systematically to verify correct loop behavior",
        "Trace loop execution manually to verify iteration counts"
      ],
      "common_misconceptions": [
        {
          "misconception": "Assuming that < and <= are interchangeable in loop conditions",
          "remedy": "Show concrete examples where the choice affects whether boundary values are included"
        },
        {
          "misconception": "Not testing loops with minimal data sets (0, 1, 2 items)",
          "remedy": "Emphasize that edge cases often reveal off-by-one errors most clearly"
        }
      ],
      "prerequisites": ["for loops", "comparison operators", "array indexing"],
      "assessment_strategies": ["boundary condition testing exercises", "loop trace verification", "bug identification problems"],
      "pedagogical_approach": "Use concrete examples with small data sets, emphasize systematic testing methodology"
    },
    {
      "id": "CSCD210-D3-S2-C2-A1",
      "title": "Trace index ranges carefully",
      "name": "Trace index ranges carefully",
      "description": "Students develop the critical skill of manually tracing through loop iterations to verify that index values stay within valid ranges and that all intended elements are processed exactly once. This systematic approach prevents array bounds exceptions and ensures complete data processing.",
      "level": 4,
      "learning_objectives": [
        "Manually trace loop execution with specific start and end values",
        "Verify that all intended array elements or data items are processed",
        "Identify when loop indices exceed valid ranges"
      ],
      "common_misconceptions": [
        {
          "misconception": "Assuming that loop bounds are correct without manual verification",
          "remedy": "Require students to trace through loops with concrete examples before implementation"
        },
        {
          "misconception": "Not considering what happens when arrays or data sets are empty",
          "remedy": "Always test loop behavior with zero-length inputs"
        }
      ],
      "prerequisites": ["array indexing", "loop variables", "manual tracing techniques"],
      "assessment_strategies": ["index trace table completion", "bounds checking exercises"]
    },
    {
      "id": "CSCD210-D3-S2-C2-A2",
      "title": "Use < vs <= appropriately",
      "name": "Use < vs <= appropriately",
      "description": "Students learn the crucial distinction between exclusive (<) and inclusive (<=) comparisons in loop conditions, understanding that this choice determines whether boundary values are included in processing. Key insight: For array processing with length n, use 'i < n' to access indices 0 through n-1, but use 'i <= target' when counting up to and including a specific target value.",
      "level": 4,
      "learning_objectives": [
        "Choose between < and <= based on whether boundary values should be included",
        "Understand how comparison choice affects loop iteration count",
        "Apply appropriate comparisons for array bounds and counting scenarios"
      ],
      "common_misconceptions": [
        {
          "misconception": "Using <= when processing arrays, leading to index out of bounds errors",
          "remedy": "Emphasize that array indices run from 0 to length-1, so use 'i < array.length'"
        },
        {
          "misconception": "Using < when counting should include the final value",
          "remedy": "Show examples where counting from 1 to 10 requires 'i <= 10', not 'i < 10'"
        }
      ],
      "prerequisites": ["comparison operators", "array indexing", "loop bounds"],
      "assessment_strategies": ["comparison operator selection exercises", "array bounds debugging"]
    },
    {
      "id": "CSCD210-D3-S2-C2-A3",
      "title": "Test boundary conditions",
      "name": "Test boundary conditions",
      "description": "Students develop systematic testing practices by deliberately checking loop behavior with edge cases: empty collections, single-element arrays, and maximum-size data sets. This testing discipline reveals off-by-one errors that might not appear with typical test data, ensuring robust loop implementation.",
      "level": 4,
      "learning_objectives": [
        "Identify critical boundary conditions for systematic testing",
        "Test loops with empty, single-element, and maximum-size inputs",
        "Verify that edge cases produce expected results without errors"
      ],
      "common_misconceptions": [
        {
          "misconception": "Only testing loops with 'normal' data sizes and overlooking edge cases",
          "remedy": "Emphasize that bugs often hide in boundary conditions that seem unlikely"
        },
        {
          "misconception": "Assuming that if a loop works for some data sizes, it works for all",
          "remedy": "Show examples where loops fail specifically on empty or single-element inputs"
        }
      ],
      "prerequisites": ["loop design", "testing methodology", "edge case analysis"],
      "assessment_strategies": ["boundary condition test design", "edge case debugging exercises"]
    },
    {
      "id": "CSCD210-D3-S2-C3",
      "title": "Loop Selection",
      "name": "Loop Selection",
      "description": "Students learn to choose the most appropriate loop construct (for, while, do-while) based on the specific characteristics of the problem, emphasizing that different loop types excel in different scenarios. This decision-making skill leads to more readable, maintainable code and demonstrates understanding of each loop's unique strengths.",
      "level": 3,
      "learning_objectives": [
        "Choose for loops when the iteration count is known in advance",
        "Select while loops for condition-based repetition with possible zero iterations",
        "Apply do-while loops when at least one iteration is guaranteed",
        "Justify loop type selection based on problem requirements"
      ],
      "common_misconceptions": [
        {
          "misconception": "Always using for loops regardless of the problem characteristics",
          "remedy": "Show examples where while or do-while loops result in cleaner, more understandable code"
        },
        {
          "misconception": "Not considering whether zero iterations should be possible",
          "remedy": "Emphasize the difference between 'might not execute' (while) vs 'executes at least once' (do-while)"
        }
      ],
      "prerequisites": ["for loops", "while loops", "do-while loops", "problem analysis"],
      "assessment_strategies": ["loop type selection justification exercises", "code readability comparisons"],
      "pedagogical_approach": "Present scenarios and have students justify their loop choice before implementation"
    },
    {
      "id": "CSCD210-D3-S2-C3-A1",
      "title": "Pick while vs do-while for user input",
      "name": "Pick while vs do-while for user input",
      "description": "Students learn to distinguish between scenarios where input validation might require zero iterations (while loop) versus situations where the user must provide at least one input attempt (do-while loop). Key decision factor: Do-while guarantees one execution, making it ideal for 'prompt until valid' patterns, while while loops handle cases where the input might already be acceptable.",
      "level": 4,
      "learning_objectives": [
        "Choose do-while when at least one user input attempt is required",
        "Select while loops when input might already meet the validation criteria",
        "Understand the 'prompt until valid' pattern and its implementation"
      ],
      "common_misconceptions": [
        {
          "misconception": "Using while loops for input validation when do-while would be more natural",
          "remedy": "Show examples where do-while eliminates awkward code duplication in input validation"
        },
        {
          "misconception": "Not considering that some validation scenarios might require zero prompts",
          "remedy": "Present cases where data might already be valid, making while loops appropriate"
        }
      ],
      "prerequisites": ["while loops", "do-while loops", "input validation"],
      "assessment_strategies": ["input validation scenario analysis", "loop pattern implementation"]
    },
    {
      "id": "CSCD210-D3-S2-C3-A2",
      "title": "Apply for loops for known counts",
      "name": "Apply for loops for known counts",
      "description": "Students recognize that for loops are the natural choice when the number of iterations is determined before the loop begins, whether through literal values, variable contents, or array lengths. The for loop's structure (initialization, condition, update) makes the iteration pattern explicit and prevents common errors like forgotten updates.",
      "level": 4,
      "learning_objectives": [
        "Identify scenarios where iteration count is known in advance",
        "Use for loops for array processing and counting operations",
        "Appreciate how for loop structure prevents infinite loop errors"
      ],
      "common_misconceptions": [
        {
          "misconception": "Using while loops for simple counting when for loops would be clearer",
          "remedy": "Show how for loops make the iteration pattern explicit and self-contained"
        },
        {
          "misconception": "Not recognizing that array.length provides a known count for iteration",
          "remedy": "Emphasize that processing all array elements is a classic for loop scenario"
        }
      ],
      "prerequisites": ["for loop structure", "counting patterns", "array processing"],
      "assessment_strategies": ["scenario analysis for loop type selection", "counting loop implementation"]
    },
    {
      "id": "CSCD210-D3-S2-C3-A3",
      "title": "Refactor repetitive code into loops",
      "name": "Refactor repetitive code into loops",
      "description": "Students develop the critical skill of recognizing repetitive code patterns and transforming them into efficient loop structures, improving code maintainability and reducing the chance of errors. This refactoring ability helps students see beyond immediate solutions to more elegant, scalable approaches.",
      "level": 4,
      "learning_objectives": [
        "Identify repetitive code patterns that could benefit from loop conversion",
        "Transform duplicated statements into parameterized loop iterations",
        "Choose appropriate loop types based on the repetition pattern"
      ],
      "common_misconceptions": [
        {
          "misconception": "Accepting code duplication without considering loop alternatives",
          "remedy": "Show examples where loops dramatically reduce code length and improve maintainability"
        },
        {
          "misconception": "Thinking that loops are only for processing collections",
          "remedy": "Demonstrate loops for repeated calculations, output formatting, and validation attempts"
        }
      ],
      "prerequisites": ["loop design", "code patterns", "refactoring concepts"],
      "assessment_strategies": ["code refactoring exercises", "pattern recognition activities"]
    },
    {
      "id": "CSCD210-D3-S3",
      "title": "Switch-Based Branching",
      "name": "Switch-Based Branching",
      "description": "Students explore switch statements as an elegant alternative to nested if/else chains when comparing a single variable against multiple discrete values. This section emphasizes understanding when switch statements improve code clarity, the critical importance of break statements, and the proper design of default cases for comprehensive coverage.",
      "level": 2,
      "learning_objectives": [
        "Identify scenarios where switch statements are more appropriate than if/else chains",
        "Implement proper break statement usage to prevent unintended fall-through",
        "Design meaningful default cases for complete condition coverage",
        "Group related cases effectively for code organization"
      ],
      "common_misconceptions": [
        {
          "misconception": "Forgetting break statements and not understanding fall-through behavior",
          "remedy": "Demonstrate fall-through with concrete examples and trace execution step-by-step"
        },
        {
          "misconception": "Trying to use switch statements for complex conditions or ranges of values",
          "remedy": "Clarify that switch only works with discrete constant values, show when if/else is still needed"
        }
      ],
      "prerequisites": ["conditional logic", "variable comparison", "control flow concepts"],
      "assessment_strategies": ["switch vs. if/else decision exercises", "fall-through debugging activities", "menu system implementation"],
      "pedagogical_approach": "Start with simple menu examples, progress to more complex state-based scenarios",
      "real_world_applications": ["menu navigation systems", "game state management", "command parsing", "enumeration handling"]
    },
    {
      "id": "CSCD210-D3-S3-C1",
      "title": "Case Labels",
      "name": "Case Labels",
      "description": "Students learn to design effective case labels in switch statements, understanding the constraints of constant expressions and the strategic use of case grouping for related actions. This section emphasizes that case labels must be compile-time constants and how intentional case grouping can eliminate code duplication.",
      "level": 3,
      "learning_objectives": [
        "Use only constant expressions (literals, final variables) in case labels",
        "Group related cases together to share common code blocks",
        "Organize case labels in logical order for code readability",
        "Handle all relevant values through comprehensive case coverage"
      ],
      "common_misconceptions": [
        {
          "misconception": "Trying to use variables or method calls in case labels",
          "remedy": "Explain that case labels must be compile-time constants, show examples of valid vs invalid labels"
        },
        {
          "misconception": "Duplicating identical code in multiple cases instead of grouping",
          "remedy": "Demonstrate how case fall-through can eliminate redundant code"
        }
      ],
      "prerequisites": ["switch statement structure", "constant expressions", "code organization"],
      "assessment_strategies": ["case label validation exercises", "code deduplication through case grouping"],
      "pedagogical_approach": "Show examples of both valid constant expressions and invalid variable usage"
    },
    {
      "id": "CSCD210-D3-S3-C1-A1",
      "title": "Match labels to constant expressions",
      "name": "Match labels to constant expressions",
      "description": "Students understand that switch case labels must be compile-time constants: literal values (1, 'a', \"hello\") or final variables initialized with constant expressions. This restriction ensures that the compiler can build efficient jump tables for switch statement execution, but means that regular variables or method return values cannot be used as case labels.",
      "level": 4,
      "learning_objectives": [
        "Identify valid constant expressions for use in case labels",
        "Distinguish between compile-time constants and runtime values",
        "Use final variables appropriately in case labels"
      ],
      "common_misconceptions": [
        {
          "misconception": "Trying to use regular variables or method calls in case labels",
          "remedy": "Show compiler errors and explain why only compile-time constants are allowed"
        },
        {
          "misconception": "Not understanding the difference between final and non-final variables in case labels",
          "remedy": "Demonstrate that final variables must be initialized with constant expressions to work in cases"
        }
      ],
      "prerequisites": ["constant expressions", "final variables", "compiler concepts"],
      "assessment_strategies": ["case label validity identification exercises", "constant expression classification"]
    },
    {
      "id": "CSCD210-D3-S3-C1-A2",
      "title": "Group cases intentionally",
      "name": "Group cases intentionally",
      "description": "Students learn to strategically group multiple case labels together when they should execute the same code block, leveraging fall-through behavior to eliminate code duplication. This technique is particularly useful for handling categories of values (like grouping all vowels, or all weekdays vs weekends) where multiple input values should trigger identical responses.",
      "level": 4,
      "learning_objectives": [
        "Identify opportunities to group related case values",
        "Use intentional fall-through to eliminate code duplication",
        "Organize case groups for logical clarity and maintainability"
      ],
      "common_misconceptions": [
        {
          "misconception": "Duplicating identical code blocks across multiple cases",
          "remedy": "Show how case grouping reduces redundancy and simplifies maintenance"
        },
        {
          "misconception": "Grouping unrelated cases just to reduce code length",
          "remedy": "Emphasize that case grouping should reflect logical relationships between values"
        }
      ],
      "prerequisites": ["switch statements", "fall-through behavior", "code organization"],
      "assessment_strategies": ["case grouping optimization exercises", "code deduplication projects"]
    },
    {
      "id": "CSCD210-D3-S3-C1-A3",
      "title": "Ensure completeness with default",
      "name": "Ensure completeness with default",
      "description": "Students understand that default cases serve as essential safety nets in switch statements, handling unexpected values and ensuring that programs respond predictably to all possible inputs. The default case should provide meaningful feedback or graceful error handling rather than silent failure, contributing to robust program design.",
      "level": 4,
      "learning_objectives": [
        "Include appropriate default cases to handle unexpected values",
        "Design meaningful responses for unmatched switch values",
        "Understand when default cases are optional vs required"
      ],
      "common_misconceptions": [
        {
          "misconception": "Omitting default cases and assuming all possible values are explicitly handled",
          "remedy": "Show examples where unexpected input causes silent program failure without default cases"
        },
        {
          "misconception": "Using empty default cases that provide no user feedback",
          "remedy": "Emphasize that default cases should inform users about unexpected values or provide appropriate alternatives"
        }
      ],
      "prerequisites": ["switch statements", "error handling", "user experience design"],
      "assessment_strategies": ["default case design exercises", "completeness analysis problems"]
    },
    {
      "id": "CSCD210-D3-S3-C2",
      "title": "Break & Fall-through",
      "name": "Break & Fall-through",
      "description": "Students master the critical concept of break statements in switch structures and understand when fall-through behavior is intentional versus accidental. This section emphasizes that break prevents execution from continuing to subsequent cases, while deliberate fall-through can eliminate code duplication when multiple cases should execute the same logic.",
      "level": 3,
      "learning_objectives": [
        "Use break statements to prevent unintended fall-through execution",
        "Recognize when fall-through behavior is beneficial for code organization",
        "Debug switch statements with missing or misplaced break statements",
        "Design intentional fall-through patterns for related case groupings"
      ],
      "common_misconceptions": [
        {
          "misconception": "Not understanding that execution continues through all subsequent cases without break",
          "remedy": "Trace execution step-by-step showing how missing breaks cause unintended behavior"
        },
        {
          "misconception": "Adding break statements to every case without considering if fall-through would be beneficial",
          "remedy": "Show examples where intentional fall-through reduces code duplication and improves maintainability"
        }
      ],
      "prerequisites": ["switch statements", "case labels", "execution flow"],
      "assessment_strategies": ["break statement debugging exercises", "fall-through design problems"],
      "pedagogical_approach": "Start with examples showing problematic fall-through, then demonstrate beneficial uses"
    },
    {
      "id": "CSCD210-D3-S3-C2-A1",
      "title": "Use break to prevent fall-through",
      "name": "Use break to prevent fall-through",
      "description": "Students learn that break statements are essential for preventing unintended execution flow in switch statements, where omitting break causes execution to 'fall through' to subsequent cases regardless of their labels. This fundamental control flow concept prevents bugs where multiple unrelated cases execute when only one was intended.",
      "level": 4,
      "learning_objectives": [
        "Place break statements appropriately to control switch execution flow",
        "Understand that break immediately exits the entire switch statement",
        "Recognize symptoms of missing break statements in program behavior"
      ],
      "common_misconceptions": [
        {
          "misconception": "Thinking that case labels automatically stop execution",
          "remedy": "Demonstrate that case labels are just entry points, not stopping points"
        },
        {
          "misconception": "Forgetting that the last case also needs a break if there's a default",
          "remedy": "Show how execution flows from the last case into default without break"
        }
      ],
      "prerequisites": ["switch statements", "control flow", "case labels"],
      "assessment_strategies": ["break placement exercises", "fall-through debugging problems"]
    },
    {
      "id": "CSCD210-D3-S3-C2-A2",
      "title": "Leverage fall-through deliberately",
      "name": "Leverage fall-through deliberately",
      "description": "Students understand that intentional fall-through (omitting break statements) can be a powerful technique for handling multiple related cases with the same logic, reducing code duplication while maintaining clarity. Common examples include grouping weekdays vs weekends, vowels vs consonants, or similar categories that require identical processing.",
      "level": 4,
      "learning_objectives": [
        "Identify scenarios where multiple cases should execute the same code",
        "Implement intentional fall-through to eliminate code duplication",
        "Document fall-through intentions clearly with comments"
      ],
      "common_misconceptions": [
        {
          "misconception": "Thinking that fall-through is always a mistake to be avoided",
          "remedy": "Show examples where fall-through creates cleaner, more maintainable code than duplication"
        },
        {
          "misconception": "Using fall-through without clear documentation or logical grouping",
          "remedy": "Emphasize that intentional fall-through should be documented and logically justified"
        }
      ],
      "prerequisites": ["break statements", "code organization", "logical grouping"],
      "assessment_strategies": ["fall-through optimization exercises", "code organization projects"]
    },
    {
      "id": "CSCD210-D3-S3-C2-A3",
      "title": "Compare with if/else chains",
      "name": "Compare with if/else chains",
      "description": "Students develop decision-making skills for choosing between switch statements and if/else chains based on the nature of the conditions being tested. Switch statements excel for discrete value matching against a single variable, while if/else chains are better for complex conditions, ranges, or multiple variable comparisons.",
      "level": 4,
      "learning_objectives": [
        "Choose appropriate control structure based on condition complexity",
        "Recognize when switch statements improve code readability over if/else chains",
        "Understand performance implications of each approach"
      ],
      "common_misconceptions": [
        {
          "misconception": "Always preferring switch statements because they seem more advanced",
          "remedy": "Show scenarios where if/else chains are clearer and more appropriate"
        },
        {
          "misconception": "Thinking that switch and if/else are always interchangeable",
          "remedy": "Demonstrate that switch only works with discrete constant values, not ranges or complex conditions"
        }
      ],
      "prerequisites": ["switch statements", "if/else chains", "condition analysis"],
      "assessment_strategies": ["control structure selection exercises", "readability comparison problems"]
    },
    {
      "id": "CSCD210-D3-S3-C3",
      "title": "Switch Expressions",
      "name": "Switch Expressions",
      "description": "Students explore modern Java switch expressions (Java 14+) that can return values directly and use arrow syntax to eliminate break statement requirements. This advanced feature allows more concise and functional programming approaches to multi-way selection while maintaining type safety and exhaustiveness checking.",
      "level": 3,
      "learning_objectives": [
        "Use arrow syntax (->) to eliminate break statements in switch expressions",
        "Return values directly from switch expressions for cleaner code",
        "Understand when switch expressions are preferable to traditional switch statements",
        "Apply switch expressions in assignment and return contexts"
      ],
      "common_misconceptions": [
        {
          "misconception": "Mixing traditional switch statement syntax with switch expression features",
          "remedy": "Clarify the distinction between statements (execute code) and expressions (return values)"
        },
        {
          "misconception": "Not understanding that switch expressions require exhaustive case coverage",
          "remedy": "Emphasize that expressions must handle all possible values or include default cases"
        }
      ],
      "prerequisites": ["traditional switch statements", "expressions vs statements", "modern Java features"],
      "assessment_strategies": ["switch expression conversion exercises", "functional programming applications"],
      "pedagogical_approach": "Introduce after mastering traditional switch statements, emphasize the value-returning nature"
    },
    {
      "id": "CSCD210-D3-S3-C3-A1",
      "title": "Use arrow syntax in modern Java",
      "name": "Use arrow syntax in modern Java",
      "description": "Students learn the arrow syntax (->) in switch expressions that eliminates the need for break statements by automatically preventing fall-through behavior. This modern syntax makes switch expressions more concise and less error-prone while clearly indicating that each case returns a value rather than executing a sequence of statements.",
      "level": 4,
      "learning_objectives": [
        "Apply arrow syntax (->) to eliminate break statement requirements",
        "Understand that arrow cases cannot fall through to subsequent cases",
        "Write more concise switch expressions using modern syntax"
      ],
      "common_misconceptions": [
        {
          "misconception": "Trying to use break statements with arrow syntax",
          "remedy": "Explain that arrow syntax automatically prevents fall-through, making break unnecessary"
        },
        {
          "misconception": "Mixing arrow syntax with traditional colon syntax in the same switch",
          "remedy": "Emphasize that all cases in a switch expression must use consistent syntax"
        }
      ],
      "prerequisites": ["switch expressions", "modern Java syntax", "expression evaluation"],
      "assessment_strategies": ["syntax conversion exercises", "modern Java feature application"]
    },
    {
      "id": "CSCD210-D3-S3-C3-A2",
      "title": "Return values from switch",
      "name": "Return values from switch",
      "description": "Students understand that switch expressions evaluate to values that can be directly assigned to variables or returned from methods, enabling more functional programming patterns. This capability allows switch expressions to replace complex if/else chains in assignment contexts, leading to cleaner and more readable code.",
      "level": 4,
      "learning_objectives": [
        "Use switch expressions in assignment statements and return contexts",
        "Understand that switch expressions must evaluate to a single value",
        "Apply switch expressions to eliminate temporary variables in conditional assignments"
      ],
      "common_misconceptions": [
        {
          "misconception": "Trying to execute multiple statements in switch expression cases",
          "remedy": "Clarify that expressions return values, while statements execute actions"
        },
        {
          "misconception": "Not ensuring all cases return the same type",
          "remedy": "Emphasize type consistency across all branches of switch expressions"
        }
      ],
      "prerequisites": ["switch expressions", "variable assignment", "return statements"],
      "assessment_strategies": ["expression assignment exercises", "functional programming conversions"]
    },
    {
      "id": "CSCD210-D3-S3-C3-A3",
      "title": "Handle exhaustive enum switches",
      "name": "Handle exhaustive enum switches",
      "description": "Students learn that switch expressions with enum types must be exhaustive, meaning they must handle all possible enum values either explicitly or through a default case. This compile-time safety feature prevents runtime errors when new enum values are added, making switch expressions particularly powerful for type-safe programming with enumerated types.",
      "level": 4,
      "learning_objectives": [
        "Ensure switch expressions handle all enum values for compile-time safety",
        "Understand how adding enum values affects existing switch expressions",
        "Use default cases appropriately with enum switch expressions"
      ],
      "common_misconceptions": [
        {
          "misconception": "Thinking that switch expressions with enums work the same as with primitive types",
          "remedy": "Demonstrate that enum switches require exhaustive coverage for compilation success"
        },
        {
          "misconception": "Not understanding how adding new enum values breaks existing code",
          "remedy": "Show how exhaustive checking prevents silent failures when enums are extended"
        }
      ],
      "prerequisites": ["enum types", "switch expressions", "compile-time checking"],
      "assessment_strategies": ["enum exhaustiveness exercises", "type safety validation problems"]
    },
    {
      "id": "CSCD210-D4",
      "title": "Method Design & Modularization",
      "name": "Method Design & Modularization",
      "description": "Students master the fundamental programming principle of breaking down complex problems into smaller, manageable, reusable code units through method design. This domain emphasizes modular programming concepts including parameter passing, return values, method overloading, and the creation of well-documented APIs that form the foundation of professional software development.",
      "level": 1,
      "learning_objectives": [
        "Design methods that follow single responsibility principle for code modularity",
        "Implement proper parameter passing and return value strategies",
        "Create reusable code components that eliminate duplication",
        "Apply method overloading to provide flexible interfaces",
        "Write comprehensive method documentation using JavaDoc standards"
      ],
      "common_misconceptions": [
        {
          "misconception": "Writing long methods that try to accomplish too many tasks",
          "remedy": "Teach the single responsibility principle and show how to break complex operations into focused methods"
        },
        {
          "misconception": "Not understanding the difference between parameters and arguments",
          "remedy": "Clarify that parameters are method definitions, arguments are values passed when calling"
        }
      ],
      "prerequisites": ["variables", "data types", "basic program structure"],
      "assessment_strategies": ["method design projects", "code refactoring exercises", "API documentation evaluation"],
      "pedagogical_approach": "Progress from simple void methods to complex parameter/return patterns, emphasize reusability",
      "real_world_applications": ["business logic implementation", "API development", "code library creation"]
    },
    {
      "id": "CSCD210-D4-S1",
      "title": "Method Definition",
      "name": "Method Definition",
      "description": "Students learn the fundamental syntax and structure of Java methods, including visibility modifiers, return types, method names, parameter lists, and method bodies. This section emphasizes professional naming conventions, clear documentation practices, and the essential components that make methods reusable and maintainable.",
      "level": 2,
      "learning_objectives": [
        "Write syntactically correct method signatures with appropriate visibility modifiers",
        "Choose descriptive method names that clearly indicate their purpose and behavior",
        "Document methods effectively using JavaDoc comments and parameter descriptions",
        "Understand the relationship between method signatures and method overloading"
      ],
      "common_misconceptions": [
        {
          "misconception": "Confusing method declaration with method invocation syntax",
          "remedy": "Show clear examples of defining methods versus calling methods with parameter passing"
        },
        {
          "misconception": "Using non-descriptive method names like doStuff() or method1()",
          "remedy": "Emphasize that method names should describe what the method accomplishes using action verbs"
        }
      ],
      "prerequisites": ["program structure", "data types", "naming conventions"],
      "assessment_strategies": ["method signature writing exercises", "documentation quality evaluation"],
      "pedagogical_approach": "Start with simple void methods, progress to parameters and return values"
    },
    {
      "id": "CSCD210-D4-S1-C1",
      "title": "Descriptive Headers",
      "name": "Descriptive Headers",
      "description": "Students develop professional method naming and documentation practices that make code self-documenting and maintainable. This includes using action verbs for method names, following Java naming conventions, and writing clear JavaDoc comments that explain the method's purpose, parameters, and return values.",
      "level": 3,
      "learning_objectives": [
        "Create method names using action verbs that clearly describe the method's purpose",
        "Apply consistent Java naming conventions (camelCase, descriptive names)",
        "Write comprehensive JavaDoc documentation for professional code quality",
        "Design method signatures that are intuitive and self-explanatory"
      ],
      "common_misconceptions": [
        {
          "misconception": "Using noun-based method names instead of action verbs",
          "remedy": "Show examples of how calculateTotal() is clearer than total() or calculation()"
        },
        {
          "misconception": "Writing minimal or missing documentation assuming code is self-explanatory",
          "remedy": "Demonstrate how good documentation prevents misunderstanding and aids maintenance"
        }
      ],
      "prerequisites": ["method syntax", "Java naming conventions", "documentation practices"],
      "assessment_strategies": ["method naming evaluation", "documentation quality assessment"],
      "pedagogical_approach": "Provide before/after examples showing poorly vs well-documented methods"
    },
    {
      "id": "CSCD210-D4-S1-C1-A1",
      "title": "Choose verbs for method names",
      "name": "Choose verbs for method names",
      "description": "Students learn that method names should begin with action verbs that clearly describe what the method accomplishes, making code self-documenting and intuitive to use. Examples include calculateTax(), validateInput(), displayResults(), or processPayment() rather than vague names like doWork() or process().",
      "level": 4,
      "learning_objectives": [
        "Use action verbs (calculate, validate, display, process) for method names",
        "Avoid vague or generic names that don't describe the method's purpose",
        "Choose names that make the method's behavior obvious to other programmers"
      ],
      "common_misconceptions": [
        {
          "misconception": "Using noun-based method names or generic terms like 'process' or 'handle'",
          "remedy": "Show specific examples: calculateTax() vs tax(), validateEmail() vs checkEmail()"
        },
        {
          "misconception": "Making method names too long with unnecessary words",
          "remedy": "Balance clarity with conciseness: calculateMonthlyPayment() not calculateTheMonthlyPaymentAmount()"
        }
      ],
      "prerequisites": ["method syntax", "Java naming conventions"],
      "assessment_strategies": ["method naming exercises", "code readability evaluation"]
    },
    {
      "id": "CSCD210-D4-S1-C1-A2",
      "title": "Specify clear parameter lists",
      "name": "Specify clear parameter lists",
      "description": "Students design parameter lists that clearly communicate what data the method needs to accomplish its task, using descriptive parameter names and appropriate data types. Well-designed parameters make methods easier to understand, use correctly, and maintain over time.",
      "level": 4,
      "learning_objectives": [
        "Choose descriptive parameter names that indicate their purpose",
        "Use appropriate data types for parameter efficiency and clarity",
        "Order parameters logically (inputs before outputs, required before optional)"
      ],
      "common_misconceptions": [
        {
          "misconception": "Using single-letter or cryptic parameter names like 'x', 'val', or 'temp'",
          "remedy": "Show examples: calculateTax(double income, double rate) vs calculateTax(double x, double y)"
        },
        {
          "misconception": "Including too many parameters, making methods difficult to use",
          "remedy": "Suggest creating objects or breaking methods into smaller pieces when parameter lists become long"
        }
      ],
      "prerequisites": ["data types", "method parameters", "naming conventions"],
      "assessment_strategies": ["parameter design exercises", "method usability evaluation"]
    },
    {
      "id": "CSCD210-D4-S1-C1-A3",
      "title": "Summarize intent with comments",
      "name": "Summarize intent with comments",
      "description": "Students write concise JavaDoc comments that explain what a method does, what parameters it expects, and what it returns, following professional documentation standards. Good method documentation serves as a contract between the method writer and users, preventing misunderstanding and reducing debugging time.",
      "level": 4,
      "learning_objectives": [
        "Write clear JavaDoc comments explaining method purpose and behavior",
        "Document all parameters with @param tags explaining their meaning and constraints",
        "Include @return tags describing what the method produces and under what conditions"
      ],
      "common_misconceptions": [
        {
          "misconception": "Writing comments that simply repeat the method name or obvious facts",
          "remedy": "Focus on WHY and WHAT rather than HOW: explain the method's purpose, not its implementation"
        },
        {
          "misconception": "Skipping documentation for 'simple' methods that seem self-explanatory",
          "remedy": "Emphasize that even simple methods benefit from brief documentation for future maintenance"
        }
      ],
      "prerequisites": ["JavaDoc syntax", "method structure", "professional documentation"],
      "assessment_strategies": ["documentation quality evaluation", "API documentation projects"]
    },
    {
      "id": "CSCD210-D4-S1-C2",
      "title": "Helper Methods",
      "name": "Helper Methods",
      "description": "Students learn to create supporting methods that break complex operations into smaller, manageable pieces, promoting code reusability and following the single responsibility principle. Helper methods eliminate code duplication, improve readability, and make testing and debugging more manageable by isolating specific functionality.",
      "level": 3,
      "learning_objectives": [
        "Identify opportunities to extract repeated code into helper methods",
        "Design helper methods that accomplish single, focused tasks",
        "Create reusable methods that can be called from multiple locations",
        "Apply proper method visibility (private vs public) for helper methods"
      ],
      "common_misconceptions": [
        {
          "misconception": "Creating methods that are too large and try to accomplish multiple tasks",
          "remedy": "Teach the single responsibility principle: each method should do one thing well"
        },
        {
          "misconception": "Duplicating code instead of recognizing opportunities for helper methods",
          "remedy": "Show before/after examples of code with and without appropriate helper method extraction"
        }
      ],
      "prerequisites": ["method definition", "code organization", "single responsibility principle"],
      "assessment_strategies": ["code refactoring exercises", "helper method identification problems"],
      "pedagogical_approach": "Start with obvious code duplication, progress to more subtle opportunities for helper methods"
    },
    {
      "id": "CSCD210-D4-S1-C2-A1",
      "title": "Decompose complex tasks",
      "name": "Decompose complex tasks",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D4-S1-C2-A2",
      "title": "Reuse code across program",
      "name": "Reuse code across program",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D4-S1-C2-A3",
      "title": "Limit method length for clarity",
      "name": "Limit method length for clarity",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D4-S1-C3",
      "title": "Javadoc Comments",
      "name": "Javadoc Comments",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D4-S1-C3-A1",
      "title": "Describe parameters with @param",
      "name": "Describe parameters with @param",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D4-S1-C3-A2",
      "title": "Explain return values",
      "name": "Explain return values",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D4-S1-C3-A3",
      "title": "Generate HTML docs",
      "name": "Generate HTML docs",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D4-S2",
      "title": "Parameter Passing",
      "name": "Parameter Passing",
      "description": "How Java passes data to methods.",
      "level": 2
    },
    {
      "id": "CSCD210-D4-S2-C1",
      "title": "Pass-by-Value",
      "name": "Pass-by-Value",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D4-S2-C1-A1",
      "title": "Explain parameter copying",
      "name": "Explain parameter copying",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D4-S2-C1-A2",
      "title": "Modify arrays via references",
      "name": "Modify arrays via references",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D4-S2-C1-A3",
      "title": "Avoid unintended mutations",
      "name": "Avoid unintended mutations",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D4-S2-C2",
      "title": "Generalize Behavior",
      "name": "Generalize Behavior",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D4-S2-C2-A1",
      "title": "Replace literals with parameters",
      "name": "Replace literals with parameters",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D4-S2-C2-A2",
      "title": "Reuse methods for new inputs",
      "name": "Reuse methods for new inputs",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D4-S2-C2-A3",
      "title": "Document parameter roles",
      "name": "Document parameter roles",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D4-S2-C3",
      "title": "Immutability Considerations",
      "name": "Immutability Considerations",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D4-S2-C3-A1",
      "title": "Prefer immutable arguments",
      "name": "Prefer immutable arguments",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D4-S2-C3-A2",
      "title": "Clone mutable inputs when needed",
      "name": "Clone mutable inputs when needed",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D4-S2-C3-A3",
      "title": "Document side effects",
      "name": "Document side effects",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D4-S3",
      "title": "Return Values & Overloading",
      "name": "Return Values & Overloading",
      "description": "Producing results and varying signatures.",
      "level": 2
    },
    {
      "id": "CSCD210-D4-S3-C1",
      "title": "Return Results",
      "name": "Return Results",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D4-S3-C1-A1",
      "title": "Use return to exit methods",
      "name": "Use return to exit methods",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D4-S3-C1-A2",
      "title": "Return computed values precisely",
      "name": "Return computed values precisely",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D4-S3-C1-A3",
      "title": "Avoid unreachable code",
      "name": "Avoid unreachable code",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D4-S3-C2",
      "title": "Method Overloading",
      "name": "Method Overloading",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D4-S3-C2-A1",
      "title": "Define multiple signatures",
      "name": "Define multiple signatures",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D4-S3-C2-A2",
      "title": "Leverage parameter types",
      "name": "Leverage parameter types",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D4-S3-C2-A3",
      "title": "Resolve overload ambiguities",
      "name": "Resolve overload ambiguities",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D4-S3-C3",
      "title": "Void vs Return",
      "name": "Void vs Return",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D4-S3-C3-A1",
      "title": "Decide when results are needed",
      "name": "Decide when results are needed",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D4-S3-C3-A2",
      "title": "Use void for actions",
      "name": "Use void for actions",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D4-S3-C3-A3",
      "title": "Refactor void to return for testing",
      "name": "Refactor void to return for testing",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5",
      "title": "Arrays & Memory",
      "name": "Arrays & Memory",
      "description": "Fixed-size collections and their memory characteristics.",
      "level": 1
    },
    {
      "id": "CSCD210-D5-S1",
      "title": "Array Creation & Indexing",
      "name": "Array Creation & Indexing",
      "description": "Instantiating arrays and addressing elements.",
      "level": 2
    },
    {
      "id": "CSCD210-D5-S1-C1",
      "title": "Allocate Arrays",
      "name": "Allocate Arrays",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D5-S1-C1-A1",
      "title": "Use new with size",
      "name": "Use new with size",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S1-C1-A2",
      "title": "Store references",
      "name": "Store references",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S1-C1-A3",
      "title": "Understand default values",
      "name": "Understand default values",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S1-C2",
      "title": "Zero-Based Indexing",
      "name": "Zero-Based Indexing",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D5-S1-C2-A1",
      "title": "Start counting at zero",
      "name": "Start counting at zero",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S1-C2-A2",
      "title": "Check bounds before access",
      "name": "Check bounds before access",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S1-C2-A3",
      "title": "Link index to length",
      "name": "Link index to length",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S1-C3",
      "title": "Length Property",
      "name": "Length Property",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D5-S1-C3-A1",
      "title": "Retrieve array length",
      "name": "Retrieve array length",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S1-C3-A2",
      "title": "Use length in loops",
      "name": "Use length in loops",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S1-C3-A3",
      "title": "Avoid hard-coded limits",
      "name": "Avoid hard-coded limits",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S2",
      "title": "Traversal Patterns",
      "name": "Traversal Patterns",
      "description": "Iterating through arrays in different ways.",
      "level": 2
    },
    {
      "id": "CSCD210-D5-S2-C1",
      "title": "Enhanced for Loop",
      "name": "Enhanced for Loop",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D5-S2-C1-A1",
      "title": "Read-only traversal",
      "name": "Read-only traversal",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S2-C1-A2",
      "title": "Avoid index errors",
      "name": "Avoid index errors",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S2-C1-A3",
      "title": "Simplify iteration syntax",
      "name": "Simplify iteration syntax",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S2-C2",
      "title": "Accumulation",
      "name": "Accumulation",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D5-S2-C2-A1",
      "title": "Sum values across array",
      "name": "Sum values across array",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S2-C2-A2",
      "title": "Compute averages",
      "name": "Compute averages",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S2-C2-A3",
      "title": "Concatenate strings",
      "name": "Concatenate strings",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S2-C3",
      "title": "Search for Extrema",
      "name": "Search for Extrema",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D5-S2-C3-A1",
      "title": "Find maximum element",
      "name": "Find maximum element",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S2-C3-A2",
      "title": "Find minimum element",
      "name": "Find minimum element",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S2-C3-A3",
      "title": "Track index of best value",
      "name": "Track index of best value",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S3",
      "title": "Array Algorithms",
      "name": "Array Algorithms",
      "description": "Common in-place array manipulations.",
      "level": 2
    },
    {
      "id": "CSCD210-D5-S3-C1",
      "title": "Element Swapping",
      "name": "Element Swapping",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D5-S3-C1-A1",
      "title": "Use temporary variable",
      "name": "Use temporary variable",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S3-C1-A2",
      "title": "Swap symmetric positions",
      "name": "Swap symmetric positions",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S3-C1-A3",
      "title": "Verify swap with prints",
      "name": "Verify swap with prints",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S3-C2",
      "title": "Reverse Array",
      "name": "Reverse Array",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D5-S3-C2-A1",
      "title": "Swap from ends inward",
      "name": "Swap from ends inward",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S3-C2-A2",
      "title": "Handle odd-length arrays",
      "name": "Handle odd-length arrays",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S3-C2-A3",
      "title": "Test with palindromes",
      "name": "Test with palindromes",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S3-C3",
      "title": "Bounds Checking",
      "name": "Bounds Checking",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D5-S3-C3-A1",
      "title": "Catch IndexOutOfBoundsException",
      "name": "Catch IndexOutOfBoundsException",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S3-C3-A2",
      "title": "Validate index input",
      "name": "Validate index input",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D5-S3-C3-A3",
      "title": "Write defensive code",
      "name": "Write defensive code",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6",
      "title": "Sorting & Searching Algorithms",
      "name": "Sorting & Searching Algorithms",
      "description": "Basic algorithmic strategies for ordering and locating data.",
      "level": 1
    },
    {
      "id": "CSCD210-D6-S1",
      "title": "Sorting Fundamentals",
      "name": "Sorting Fundamentals",
      "description": "Elementary comparison-based sorting methods.",
      "level": 2
    },
    {
      "id": "CSCD210-D6-S1-C1",
      "title": "Selection Sort",
      "name": "Selection Sort",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D6-S1-C1-A1",
      "title": "Trace selection sort by hand",
      "name": "Trace selection sort by hand",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S1-C1-A2",
      "title": "Select smallest remaining element",
      "name": "Select smallest remaining element",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S1-C1-A3",
      "title": "Swap into sorted position",
      "name": "Swap into sorted position",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S1-C2",
      "title": "Bubble Sort",
      "name": "Bubble Sort",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D6-S1-C2-A1",
      "title": "Swap adjacent out-of-order pairs",
      "name": "Swap adjacent out-of-order pairs",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S1-C2-A2",
      "title": "Detect early completion",
      "name": "Detect early completion",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S1-C2-A3",
      "title": "Count passes to understand cost",
      "name": "Count passes to understand cost",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S1-C3",
      "title": "Stability Comparison",
      "name": "Stability Comparison",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D6-S1-C3-A1",
      "title": "Define stable sorting",
      "name": "Define stable sorting",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S1-C3-A2",
      "title": "Give examples of stable vs unstable",
      "name": "Give examples of stable vs unstable",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S1-C3-A3",
      "title": "Choose algorithm based on stability",
      "name": "Choose algorithm based on stability",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S2",
      "title": "Searching Techniques",
      "name": "Searching Techniques",
      "description": "Strategies to find elements in arrays.",
      "level": 2
    },
    {
      "id": "CSCD210-D6-S2-C1",
      "title": "Linear Search",
      "name": "Linear Search",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D6-S2-C1-A1",
      "title": "Scan unsorted arrays",
      "name": "Scan unsorted arrays",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S2-C1-A2",
      "title": "Return index when found",
      "name": "Return index when found",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S2-C1-A3",
      "title": "Return -1 when absent",
      "name": "Return -1 when absent",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S2-C2",
      "title": "Binary Search",
      "name": "Binary Search",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D6-S2-C2-A1",
      "title": "Require sorted input",
      "name": "Require sorted input",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S2-C2-A2",
      "title": "Halve search space each step",
      "name": "Halve search space each step",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S2-C2-A3",
      "title": "Track low and high indices",
      "name": "Track low and high indices",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S2-C3",
      "title": "Reporting Missing",
      "name": "Reporting Missing",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D6-S2-C3-A1",
      "title": "Signal not-found clearly",
      "name": "Signal not-found clearly",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S2-C3-A2",
      "title": "Explain null vs -1 returns",
      "name": "Explain null vs -1 returns",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S2-C3-A3",
      "title": "Test with absent data",
      "name": "Test with absent data",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S3",
      "title": "Algorithm Efficiency",
      "name": "Algorithm Efficiency",
      "description": "Reasoning about performance.",
      "level": 2
    },
    {
      "id": "CSCD210-D6-S3-C1",
      "title": "Count Comparisons",
      "name": "Count Comparisons",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D6-S3-C1-A1",
      "title": "Tally comparisons in algorithms",
      "name": "Tally comparisons in algorithms",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S3-C1-A2",
      "title": "Relate counts to Big-O",
      "name": "Relate counts to Big-O",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S3-C1-A3",
      "title": "Optimize inner loops",
      "name": "Optimize inner loops",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S3-C2",
      "title": "Big-O Notation",
      "name": "Big-O Notation",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D6-S3-C2-A1",
      "title": "Describe O(n) vs O(log n)",
      "name": "Describe O(n) vs O(log n)",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S3-C2-A2",
      "title": "Explain worst-case behavior",
      "name": "Explain worst-case behavior",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S3-C2-A3",
      "title": "Choose algorithm based on growth",
      "name": "Choose algorithm based on growth",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S3-C3",
      "title": "Choosing Algorithms",
      "name": "Choosing Algorithms",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D6-S3-C3-A1",
      "title": "Match algorithm to data size",
      "name": "Match algorithm to data size",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S3-C3-A2",
      "title": "Balance readability and speed",
      "name": "Balance readability and speed",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D6-S3-C3-A3",
      "title": "Justify choice in comments",
      "name": "Justify choice in comments",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7",
      "title": "File I/O & Data Persistence",
      "name": "File I/O & Data Persistence",
      "description": "Working with external data sources using Java streams.",
      "level": 1
    },
    {
      "id": "CSCD210-D7-S1",
      "title": "Reading Text Files",
      "name": "Reading Text Files",
      "description": "Loading data with Scanner and file paths.",
      "level": 2
    },
    {
      "id": "CSCD210-D7-S1-C1",
      "title": "Scanner with File",
      "name": "Scanner with File",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D7-S1-C1-A1",
      "title": "Construct Scanner with File object",
      "name": "Construct Scanner with File object",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S1-C1-A2",
      "title": "Read line by line until EOF",
      "name": "Read line by line until EOF",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S1-C1-A3",
      "title": "Close Scanner to free handle",
      "name": "Close Scanner to free handle",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S1-C2",
      "title": "Parsing Lines",
      "name": "Parsing Lines",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D7-S1-C2-A1",
      "title": "Split input into tokens",
      "name": "Split input into tokens",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S1-C2-A2",
      "title": "Convert text to numbers",
      "name": "Convert text to numbers",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S1-C2-A3",
      "title": "Handle malformed input gracefully",
      "name": "Handle malformed input gracefully",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S1-C3",
      "title": "Resource Management",
      "name": "Resource Management",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D7-S1-C3-A1",
      "title": "Use try-with-resources",
      "name": "Use try-with-resources",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S1-C3-A2",
      "title": "Catch FileNotFoundException",
      "name": "Catch FileNotFoundException",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S1-C3-A3",
      "title": "Ensure file handles close",
      "name": "Ensure file handles close",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S2",
      "title": "Writing Text Files",
      "name": "Writing Text Files",
      "description": "Persisting output using PrintStream.",
      "level": 2
    },
    {
      "id": "CSCD210-D7-S2-C1",
      "title": "Create PrintStream",
      "name": "Create PrintStream",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D7-S2-C1-A1",
      "title": "Open file for writing",
      "name": "Open file for writing",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S2-C1-A2",
      "title": "Write formatted lines",
      "name": "Write formatted lines",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S2-C1-A3",
      "title": "Flush and close stream",
      "name": "Flush and close stream",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S2-C2",
      "title": "DecimalFormat Usage",
      "name": "DecimalFormat Usage",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D7-S2-C2-A1",
      "title": "Format numbers to fixed decimals",
      "name": "Format numbers to fixed decimals",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S2-C2-A2",
      "title": "Include thousand separators",
      "name": "Include thousand separators",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S2-C2-A3",
      "title": "Reuse formatters for efficiency",
      "name": "Reuse formatters for efficiency",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S2-C3",
      "title": "Append vs Overwrite",
      "name": "Append vs Overwrite",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D7-S2-C3-A1",
      "title": "Open file in append mode",
      "name": "Open file in append mode",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S2-C3-A2",
      "title": "Warn before overwriting",
      "name": "Warn before overwriting",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S2-C3-A3",
      "title": "Check file existence",
      "name": "Check file existence",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S3",
      "title": "Checked Exceptions",
      "name": "Checked Exceptions",
      "description": "Handling mandatory exceptions in file operations.",
      "level": 2
    },
    {
      "id": "CSCD210-D7-S3-C1",
      "title": "Declare Throws",
      "name": "Declare Throws",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D7-S3-C1-A1",
      "title": "Add throws to method signatures",
      "name": "Add throws to method signatures",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S3-C1-A2",
      "title": "Propagate FileNotFoundException",
      "name": "Propagate FileNotFoundException",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S3-C1-A3",
      "title": "Differentiate checked and runtime",
      "name": "Differentiate checked and runtime",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S3-C2",
      "title": "Catch IOException",
      "name": "Catch IOException",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D7-S3-C2-A1",
      "title": "Wrap risky code in try/catch",
      "name": "Wrap risky code in try/catch",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S3-C2-A2",
      "title": "Print user-friendly messages",
      "name": "Print user-friendly messages",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S3-C2-A3",
      "title": "Recover or exit cleanly",
      "name": "Recover or exit cleanly",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S3-C3",
      "title": "Runtime vs Checked",
      "name": "Runtime vs Checked",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D7-S3-C3-A1",
      "title": "Classify common exceptions",
      "name": "Classify common exceptions",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S3-C3-A2",
      "title": "Choose between throws and catch",
      "name": "Choose between throws and catch",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D7-S3-C3-A3",
      "title": "Handle unexpected runtime errors",
      "name": "Handle unexpected runtime errors",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8",
      "title": "Program Development Lifecycle",
      "name": "Program Development Lifecycle",
      "description": "Steps for building reliable Java programs.",
      "level": 1
    },
    {
      "id": "CSCD210-D8-S1",
      "title": "Compilation & Execution",
      "name": "Compilation & Execution",
      "description": "From source code to running application.",
      "level": 2
    },
    {
      "id": "CSCD210-D8-S1-C1",
      "title": "javac Compiler",
      "name": "javac Compiler",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D8-S1-C1-A1",
      "title": "Compile multiple source files",
      "name": "Compile multiple source files",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S1-C1-A2",
      "title": "Interpret compiler diagnostics",
      "name": "Interpret compiler diagnostics",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S1-C1-A3",
      "title": "Set classpath when needed",
      "name": "Set classpath when needed",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S1-C2",
      "title": "Running Classes",
      "name": "Running Classes",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D8-S1-C2-A1",
      "title": "Invoke java with class name",
      "name": "Invoke java with class name",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S1-C2-A2",
      "title": "Pass command-line arguments",
      "name": "Pass command-line arguments",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S1-C2-A3",
      "title": "Use package-qualified names",
      "name": "Use package-qualified names",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S1-C3",
      "title": "Build Tools",
      "name": "Build Tools",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D8-S1-C3-A1",
      "title": "Use IDE build buttons",
      "name": "Use IDE build buttons",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S1-C3-A2",
      "title": "Trigger Maven compile",
      "name": "Trigger Maven compile",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S1-C3-A3",
      "title": "Recognize build artifacts",
      "name": "Recognize build artifacts",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S2",
      "title": "Debugging Strategies",
      "name": "Debugging Strategies",
      "description": "Finding and fixing defects.",
      "level": 2
    },
    {
      "id": "CSCD210-D8-S2-C1",
      "title": "Breakpoints",
      "name": "Breakpoints",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D8-S2-C1-A1",
      "title": "Pause program mid-execution",
      "name": "Pause program mid-execution",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S2-C1-A2",
      "title": "Step through lines",
      "name": "Step through lines",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S2-C1-A3",
      "title": "Inspect variable values",
      "name": "Inspect variable values",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S2-C2",
      "title": "Print Debugging",
      "name": "Print Debugging",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D8-S2-C2-A1",
      "title": "Insert temporary printlns",
      "name": "Insert temporary printlns",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S2-C2-A2",
      "title": "Label outputs clearly",
      "name": "Label outputs clearly",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S2-C2-A3",
      "title": "Remove debug prints after fixing",
      "name": "Remove debug prints after fixing",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S2-C3",
      "title": "Stack Traces",
      "name": "Stack Traces",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D8-S2-C3-A1",
      "title": "Read stack trace top to bottom",
      "name": "Read stack trace top to bottom",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S2-C3-A2",
      "title": "Locate origin of exception",
      "name": "Locate origin of exception",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S2-C3-A3",
      "title": "Map line numbers to source",
      "name": "Map line numbers to source",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S3",
      "title": "Testing & Evaluation",
      "name": "Testing & Evaluation",
      "description": "Ensuring code meets requirements.",
      "level": 2
    },
    {
      "id": "CSCD210-D8-S3-C1",
      "title": "Unit Tests",
      "name": "Unit Tests",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D8-S3-C1-A1",
      "title": "Write assert statements",
      "name": "Write assert statements",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S3-C1-A2",
      "title": "Test typical and edge cases",
      "name": "Test typical and edge cases",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S3-C1-A3",
      "title": "Automate tests with JUnit",
      "name": "Automate tests with JUnit",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S3-C2",
      "title": "Input Validation",
      "name": "Input Validation",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D8-S3-C2-A1",
      "title": "Check user input for range",
      "name": "Check user input for range",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S3-C2-A2",
      "title": "Re-prompt on invalid data",
      "name": "Re-prompt on invalid data",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S3-C2-A3",
      "title": "Separate validation logic",
      "name": "Separate validation logic",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S3-C3",
      "title": "Refactoring",
      "name": "Refactoring",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D8-S3-C3-A1",
      "title": "Improve code without changing behavior",
      "name": "Improve code without changing behavior",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S3-C3-A2",
      "title": "Rename variables for clarity",
      "name": "Rename variables for clarity",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D8-S3-C3-A3",
      "title": "Extract methods during cleanup",
      "name": "Extract methods during cleanup",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9",
      "title": "Hardware Organization & Execution Model",
      "name": "Hardware Organization & Execution Model",
      "description": "Foundational computer architecture concepts supporting Java execution.",
      "level": 1
    },
    {
      "id": "CSCD210-D9-S1",
      "title": "CPU Fundamentals",
      "name": "CPU Fundamentals",
      "description": "Core components driving computation.",
      "level": 2
    },
    {
      "id": "CSCD210-D9-S1-C1",
      "title": "ALU and Control Unit",
      "name": "ALU and Control Unit",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D9-S1-C1-A1",
      "title": "Identify arithmetic vs logic roles",
      "name": "Identify arithmetic vs logic roles",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S1-C1-A2",
      "title": "Explain control signals",
      "name": "Explain control signals",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S1-C1-A3",
      "title": "Relate CPU parts to program flow",
      "name": "Relate CPU parts to program flow",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S1-C2",
      "title": "Clock Cycles",
      "name": "Clock Cycles",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D9-S1-C2-A1",
      "title": "Define Hertz as cycles per second",
      "name": "Define Hertz as cycles per second",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S1-C2-A2",
      "title": "Relate clock speed to performance",
      "name": "Relate clock speed to performance",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S1-C2-A3",
      "title": "Understand pipeline effects",
      "name": "Understand pipeline effects",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S1-C3",
      "title": "Instruction Set Architecture",
      "name": "Instruction Set Architecture",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D9-S1-C3-A1",
      "title": "Describe ISA at high level",
      "name": "Describe ISA at high level",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S1-C3-A2",
      "title": "Differentiate RISC vs CISC",
      "name": "Differentiate RISC vs CISC",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S1-C3-A3",
      "title": "Connect bytecode to ISA commands",
      "name": "Connect bytecode to ISA commands",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S2",
      "title": "Memory Hierarchy",
      "name": "Memory Hierarchy",
      "description": "Organization from registers to storage.",
      "level": 2
    },
    {
      "id": "CSCD210-D9-S2-C1",
      "title": "RAM vs Storage",
      "name": "RAM vs Storage",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D9-S2-C1-A1",
      "title": "Contrast volatility",
      "name": "Contrast volatility",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S2-C1-A2",
      "title": "Measure access times",
      "name": "Measure access times",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S2-C1-A3",
      "title": "Explain role of SSD/HDD",
      "name": "Explain role of SSD/HDD",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S2-C2",
      "title": "Cache Purpose",
      "name": "Cache Purpose",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D9-S2-C2-A1",
      "title": "Describe locality of reference",
      "name": "Describe locality of reference",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S2-C2-A2",
      "title": "Show how cache speeds access",
      "name": "Show how cache speeds access",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S2-C2-A3",
      "title": "Identify cache misses",
      "name": "Identify cache misses",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S2-C3",
      "title": "Memory Allocation",
      "name": "Memory Allocation",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D9-S2-C3-A1",
      "title": "Relate variable types to stack or heap",
      "name": "Relate variable types to stack or heap",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S2-C3-A2",
      "title": "Trace object references",
      "name": "Trace object references",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S2-C3-A3",
      "title": "Explain garbage collection basics",
      "name": "Explain garbage collection basics",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S3",
      "title": "Instruction Lifecycle",
      "name": "Instruction Lifecycle",
      "description": "How instructions move through hardware.",
      "level": 2
    },
    {
      "id": "CSCD210-D9-S3-C1",
      "title": "Fetch-Decode-Execute",
      "name": "Fetch-Decode-Execute",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D9-S3-C1-A1",
      "title": "Outline each phase",
      "name": "Outline each phase",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S3-C1-A2",
      "title": "Connect Java statements to machine steps",
      "name": "Connect Java statements to machine steps",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S3-C1-A3",
      "title": "Relate program counter to flow",
      "name": "Relate program counter to flow",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S3-C2",
      "title": "Bytecode Interpretation",
      "name": "Bytecode Interpretation",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D9-S3-C2-A1",
      "title": "Describe role of JVM",
      "name": "Describe role of JVM",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S3-C2-A2",
      "title": "Explain just-in-time compilation",
      "name": "Explain just-in-time compilation",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S3-C2-A3",
      "title": "Map bytecode to native instructions",
      "name": "Map bytecode to native instructions",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S3-C3",
      "title": "Loops to Machine",
      "name": "Loops to Machine",
      "description": "",
      "level": 3
    },
    {
      "id": "CSCD210-D9-S3-C3-A1",
      "title": "Translate high-level loops to jumps",
      "name": "Translate high-level loops to jumps",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S3-C3-A2",
      "title": "Predict iteration cost",
      "name": "Predict iteration cost",
      "description": "",
      "level": 4
    },
    {
      "id": "CSCD210-D9-S3-C3-A3",
      "title": "Recognize hardware branch prediction",
      "name": "Recognize hardware branch prediction",
      "description": "",
      "level": 4
    }
  ],
  "links": [
    {
      "source": "CSCD210-D1",
      "target": "CSCD210"
    },
    {
      "source": "CSCD210-D1-S1",
      "target": "CSCD210-D1"
    },
    {
      "source": "CSCD210-D1-S1-C1",
      "target": "CSCD210-D1-S1"
    },
    {
      "source": "CSCD210-D1-S1-C1-A1",
      "target": "CSCD210-D1-S1-C1"
    },
    {
      "source": "CSCD210-D1-S1-C1-A2",
      "target": "CSCD210-D1-S1-C1"
    },
    {
      "source": "CSCD210-D1-S1-C1-A3",
      "target": "CSCD210-D1-S1-C1"
    },
    {
      "source": "CSCD210-D1-S1-C2",
      "target": "CSCD210-D1-S1"
    },
    {
      "source": "CSCD210-D1-S1-C2-A1",
      "target": "CSCD210-D1-S1-C2"
    },
    {
      "source": "CSCD210-D1-S1-C2-A2",
      "target": "CSCD210-D1-S1-C2"
    },
    {
      "source": "CSCD210-D1-S1-C2-A3",
      "target": "CSCD210-D1-S1-C2"
    },
    {
      "source": "CSCD210-D1-S1-C3",
      "target": "CSCD210-D1-S1"
    },
    {
      "source": "CSCD210-D1-S1-C3-A1",
      "target": "CSCD210-D1-S1-C3"
    },
    {
      "source": "CSCD210-D1-S1-C3-A2",
      "target": "CSCD210-D1-S1-C3"
    },
    {
      "source": "CSCD210-D1-S1-C3-A3",
      "target": "CSCD210-D1-S1-C3"
    },
    {
      "source": "CSCD210-D1-S2",
      "target": "CSCD210-D1"
    },
    {
      "source": "CSCD210-D1-S2-C1",
      "target": "CSCD210-D1-S2"
    },
    {
      "source": "CSCD210-D1-S2-C1-A1",
      "target": "CSCD210-D1-S2-C1"
    },
    {
      "source": "CSCD210-D1-S2-C1-A2",
      "target": "CSCD210-D1-S2-C1"
    },
    {
      "source": "CSCD210-D1-S2-C1-A3",
      "target": "CSCD210-D1-S2-C1"
    },
    {
      "source": "CSCD210-D1-S2-C2",
      "target": "CSCD210-D1-S2"
    },
    {
      "source": "CSCD210-D1-S2-C2-A1",
      "target": "CSCD210-D1-S2-C2"
    },
    {
      "source": "CSCD210-D1-S2-C2-A2",
      "target": "CSCD210-D1-S2-C2"
    },
    {
      "source": "CSCD210-D1-S2-C2-A3",
      "target": "CSCD210-D1-S2-C2"
    },
    {
      "source": "CSCD210-D1-S2-C3",
      "target": "CSCD210-D1-S2"
    },
    {
      "source": "CSCD210-D1-S2-C3-A1",
      "target": "CSCD210-D1-S2-C3"
    },
    {
      "source": "CSCD210-D1-S2-C3-A2",
      "target": "CSCD210-D1-S2-C3"
    },
    {
      "source": "CSCD210-D1-S2-C3-A3",
      "target": "CSCD210-D1-S2-C3"
    },
    {
      "source": "CSCD210-D1-S3",
      "target": "CSCD210-D1"
    },
    {
      "source": "CSCD210-D1-S3-C1",
      "target": "CSCD210-D1-S3"
    },
    {
      "source": "CSCD210-D1-S3-C1-A1",
      "target": "CSCD210-D1-S3-C1"
    },
    {
      "source": "CSCD210-D1-S3-C1-A2",
      "target": "CSCD210-D1-S3-C1"
    },
    {
      "source": "CSCD210-D1-S3-C1-A3",
      "target": "CSCD210-D1-S3-C1"
    },
    {
      "source": "CSCD210-D1-S3-C2",
      "target": "CSCD210-D1-S3"
    },
    {
      "source": "CSCD210-D1-S3-C2-A1",
      "target": "CSCD210-D1-S3-C2"
    },
    {
      "source": "CSCD210-D1-S3-C2-A2",
      "target": "CSCD210-D1-S3-C2"
    },
    {
      "source": "CSCD210-D1-S3-C2-A3",
      "target": "CSCD210-D1-S3-C2"
    },
    {
      "source": "CSCD210-D1-S3-C3",
      "target": "CSCD210-D1-S3"
    },
    {
      "source": "CSCD210-D1-S3-C3-A1",
      "target": "CSCD210-D1-S3-C3"
    },
    {
      "source": "CSCD210-D1-S3-C3-A2",
      "target": "CSCD210-D1-S3-C3"
    },
    {
      "source": "CSCD210-D1-S3-C3-A3",
      "target": "CSCD210-D1-S3-C3"
    },
    {
      "source": "CSCD210-D2",
      "target": "CSCD210"
    },
    {
      "source": "CSCD210-D2-S1",
      "target": "CSCD210-D2"
    },
    {
      "source": "CSCD210-D2-S1-C1",
      "target": "CSCD210-D2-S1"
    },
    {
      "source": "CSCD210-D2-S1-C1-A1",
      "target": "CSCD210-D2-S1-C1"
    },
    {
      "source": "CSCD210-D2-S1-C1-A2",
      "target": "CSCD210-D2-S1-C1"
    },
    {
      "source": "CSCD210-D2-S1-C1-A3",
      "target": "CSCD210-D2-S1-C1"
    },
    {
      "source": "CSCD210-D2-S1-C2",
      "target": "CSCD210-D2-S1"
    },
    {
      "source": "CSCD210-D2-S1-C2-A1",
      "target": "CSCD210-D2-S1-C2"
    },
    {
      "source": "CSCD210-D2-S1-C2-A2",
      "target": "CSCD210-D2-S1-C2"
    },
    {
      "source": "CSCD210-D2-S1-C2-A3",
      "target": "CSCD210-D2-S1-C2"
    },
    {
      "source": "CSCD210-D2-S1-C3",
      "target": "CSCD210-D2-S1"
    },
    {
      "source": "CSCD210-D2-S1-C3-A1",
      "target": "CSCD210-D2-S1-C3"
    },
    {
      "source": "CSCD210-D2-S1-C3-A2",
      "target": "CSCD210-D2-S1-C3"
    },
    {
      "source": "CSCD210-D2-S1-C3-A3",
      "target": "CSCD210-D2-S1-C3"
    },
    {
      "source": "CSCD210-D2-S2",
      "target": "CSCD210-D2"
    },
    {
      "source": "CSCD210-D2-S2-C1",
      "target": "CSCD210-D2-S2"
    },
    {
      "source": "CSCD210-D2-S2-C1-A1",
      "target": "CSCD210-D2-S2-C1"
    },
    {
      "source": "CSCD210-D2-S2-C1-A2",
      "target": "CSCD210-D2-S2-C1"
    },
    {
      "source": "CSCD210-D2-S2-C1-A3",
      "target": "CSCD210-D2-S2-C1"
    },
    {
      "source": "CSCD210-D2-S2-C2",
      "target": "CSCD210-D2-S2"
    },
    {
      "source": "CSCD210-D2-S2-C2-A1",
      "target": "CSCD210-D2-S2-C2"
    },
    {
      "source": "CSCD210-D2-S2-C2-A2",
      "target": "CSCD210-D2-S2-C2"
    },
    {
      "source": "CSCD210-D2-S2-C2-A3",
      "target": "CSCD210-D2-S2-C2"
    },
    {
      "source": "CSCD210-D2-S2-C3",
      "target": "CSCD210-D2-S2"
    },
    {
      "source": "CSCD210-D2-S2-C3-A1",
      "target": "CSCD210-D2-S2-C3"
    },
    {
      "source": "CSCD210-D2-S2-C3-A2",
      "target": "CSCD210-D2-S2-C3"
    },
    {
      "source": "CSCD210-D2-S2-C3-A3",
      "target": "CSCD210-D2-S2-C3"
    },
    {
      "source": "CSCD210-D2-S3",
      "target": "CSCD210-D2"
    },
    {
      "source": "CSCD210-D2-S3-C1",
      "target": "CSCD210-D2-S3"
    },
    {
      "source": "CSCD210-D2-S3-C1-A1",
      "target": "CSCD210-D2-S3-C1"
    },
    {
      "source": "CSCD210-D2-S3-C1-A2",
      "target": "CSCD210-D2-S3-C1"
    },
    {
      "source": "CSCD210-D2-S3-C1-A3",
      "target": "CSCD210-D2-S3-C1"
    },
    {
      "source": "CSCD210-D2-S3-C2",
      "target": "CSCD210-D2-S3"
    },
    {
      "source": "CSCD210-D2-S3-C2-A1",
      "target": "CSCD210-D2-S3-C2"
    },
    {
      "source": "CSCD210-D2-S3-C2-A2",
      "target": "CSCD210-D2-S3-C2"
    },
    {
      "source": "CSCD210-D2-S3-C2-A3",
      "target": "CSCD210-D2-S3-C2"
    },
    {
      "source": "CSCD210-D2-S3-C3",
      "target": "CSCD210-D2-S3"
    },
    {
      "source": "CSCD210-D2-S3-C3-A1",
      "target": "CSCD210-D2-S3-C3"
    },
    {
      "source": "CSCD210-D2-S3-C3-A2",
      "target": "CSCD210-D2-S3-C3"
    },
    {
      "source": "CSCD210-D2-S3-C3-A3",
      "target": "CSCD210-D2-S3-C3"
    },
    {
      "source": "CSCD210-D3",
      "target": "CSCD210"
    },
    {
      "source": "CSCD210-D3-S1",
      "target": "CSCD210-D3"
    },
    {
      "source": "CSCD210-D3-S1-C1",
      "target": "CSCD210-D3-S1"
    },
    {
      "source": "CSCD210-D3-S1-C1-A1",
      "target": "CSCD210-D3-S1-C1"
    },
    {
      "source": "CSCD210-D3-S1-C1-A2",
      "target": "CSCD210-D3-S1-C1"
    },
    {
      "source": "CSCD210-D3-S1-C1-A3",
      "target": "CSCD210-D3-S1-C1"
    },
    {
      "source": "CSCD210-D3-S1-C2",
      "target": "CSCD210-D3-S1"
    },
    {
      "source": "CSCD210-D3-S1-C2-A1",
      "target": "CSCD210-D3-S1-C2"
    },
    {
      "source": "CSCD210-D3-S1-C2-A2",
      "target": "CSCD210-D3-S1-C2"
    },
    {
      "source": "CSCD210-D3-S1-C2-A3",
      "target": "CSCD210-D3-S1-C2"
    },
    {
      "source": "CSCD210-D3-S1-C3",
      "target": "CSCD210-D3-S1"
    },
    {
      "source": "CSCD210-D3-S1-C3-A1",
      "target": "CSCD210-D3-S1-C3"
    },
    {
      "source": "CSCD210-D3-S1-C3-A2",
      "target": "CSCD210-D3-S1-C3"
    },
    {
      "source": "CSCD210-D3-S1-C3-A3",
      "target": "CSCD210-D3-S1-C3"
    },
    {
      "source": "CSCD210-D3-S2",
      "target": "CSCD210-D3"
    },
    {
      "source": "CSCD210-D3-S2-C1",
      "target": "CSCD210-D3-S2"
    },
    {
      "source": "CSCD210-D3-S2-C1-A1",
      "target": "CSCD210-D3-S2-C1"
    },
    {
      "source": "CSCD210-D3-S2-C1-A2",
      "target": "CSCD210-D3-S2-C1"
    },
    {
      "source": "CSCD210-D3-S2-C1-A3",
      "target": "CSCD210-D3-S2-C1"
    },
    {
      "source": "CSCD210-D3-S2-C2",
      "target": "CSCD210-D3-S2"
    },
    {
      "source": "CSCD210-D3-S2-C2-A1",
      "target": "CSCD210-D3-S2-C2"
    },
    {
      "source": "CSCD210-D3-S2-C2-A2",
      "target": "CSCD210-D3-S2-C2"
    },
    {
      "source": "CSCD210-D3-S2-C2-A3",
      "target": "CSCD210-D3-S2-C2"
    },
    {
      "source": "CSCD210-D3-S2-C3",
      "target": "CSCD210-D3-S2"
    },
    {
      "source": "CSCD210-D3-S2-C3-A1",
      "target": "CSCD210-D3-S2-C3"
    },
    {
      "source": "CSCD210-D3-S2-C3-A2",
      "target": "CSCD210-D3-S2-C3"
    },
    {
      "source": "CSCD210-D3-S2-C3-A3",
      "target": "CSCD210-D3-S2-C3"
    },
    {
      "source": "CSCD210-D3-S3",
      "target": "CSCD210-D3"
    },
    {
      "source": "CSCD210-D3-S3-C1",
      "target": "CSCD210-D3-S3"
    },
    {
      "source": "CSCD210-D3-S3-C1-A1",
      "target": "CSCD210-D3-S3-C1"
    },
    {
      "source": "CSCD210-D3-S3-C1-A2",
      "target": "CSCD210-D3-S3-C1"
    },
    {
      "source": "CSCD210-D3-S3-C1-A3",
      "target": "CSCD210-D3-S3-C1"
    },
    {
      "source": "CSCD210-D3-S3-C2",
      "target": "CSCD210-D3-S3"
    },
    {
      "source": "CSCD210-D3-S3-C2-A1",
      "target": "CSCD210-D3-S3-C2"
    },
    {
      "source": "CSCD210-D3-S3-C2-A2",
      "target": "CSCD210-D3-S3-C2"
    },
    {
      "source": "CSCD210-D3-S3-C2-A3",
      "target": "CSCD210-D3-S3-C2"
    },
    {
      "source": "CSCD210-D3-S3-C3",
      "target": "CSCD210-D3-S3"
    },
    {
      "source": "CSCD210-D3-S3-C3-A1",
      "target": "CSCD210-D3-S3-C3"
    },
    {
      "source": "CSCD210-D3-S3-C3-A2",
      "target": "CSCD210-D3-S3-C3"
    },
    {
      "source": "CSCD210-D3-S3-C3-A3",
      "target": "CSCD210-D3-S3-C3"
    },
    {
      "source": "CSCD210-D4",
      "target": "CSCD210"
    },
    {
      "source": "CSCD210-D4-S1",
      "target": "CSCD210-D4"
    },
    {
      "source": "CSCD210-D4-S1-C1",
      "target": "CSCD210-D4-S1"
    },
    {
      "source": "CSCD210-D4-S1-C1-A1",
      "target": "CSCD210-D4-S1-C1"
    },
    {
      "source": "CSCD210-D4-S1-C1-A2",
      "target": "CSCD210-D4-S1-C1"
    },
    {
      "source": "CSCD210-D4-S1-C1-A3",
      "target": "CSCD210-D4-S1-C1"
    },
    {
      "source": "CSCD210-D4-S1-C2",
      "target": "CSCD210-D4-S1"
    },
    {
      "source": "CSCD210-D4-S1-C2-A1",
      "target": "CSCD210-D4-S1-C2"
    },
    {
      "source": "CSCD210-D4-S1-C2-A2",
      "target": "CSCD210-D4-S1-C2"
    },
    {
      "source": "CSCD210-D4-S1-C2-A3",
      "target": "CSCD210-D4-S1-C2"
    },
    {
      "source": "CSCD210-D4-S1-C3",
      "target": "CSCD210-D4-S1"
    },
    {
      "source": "CSCD210-D4-S1-C3-A1",
      "target": "CSCD210-D4-S1-C3"
    },
    {
      "source": "CSCD210-D4-S1-C3-A2",
      "target": "CSCD210-D4-S1-C3"
    },
    {
      "source": "CSCD210-D4-S1-C3-A3",
      "target": "CSCD210-D4-S1-C3"
    },
    {
      "source": "CSCD210-D4-S2",
      "target": "CSCD210-D4"
    },
    {
      "source": "CSCD210-D4-S2-C1",
      "target": "CSCD210-D4-S2"
    },
    {
      "source": "CSCD210-D4-S2-C1-A1",
      "target": "CSCD210-D4-S2-C1"
    },
    {
      "source": "CSCD210-D4-S2-C1-A2",
      "target": "CSCD210-D4-S2-C1"
    },
    {
      "source": "CSCD210-D4-S2-C1-A3",
      "target": "CSCD210-D4-S2-C1"
    },
    {
      "source": "CSCD210-D4-S2-C2",
      "target": "CSCD210-D4-S2"
    },
    {
      "source": "CSCD210-D4-S2-C2-A1",
      "target": "CSCD210-D4-S2-C2"
    },
    {
      "source": "CSCD210-D4-S2-C2-A2",
      "target": "CSCD210-D4-S2-C2"
    },
    {
      "source": "CSCD210-D4-S2-C2-A3",
      "target": "CSCD210-D4-S2-C2"
    },
    {
      "source": "CSCD210-D4-S2-C3",
      "target": "CSCD210-D4-S2"
    },
    {
      "source": "CSCD210-D4-S2-C3-A1",
      "target": "CSCD210-D4-S2-C3"
    },
    {
      "source": "CSCD210-D4-S2-C3-A2",
      "target": "CSCD210-D4-S2-C3"
    },
    {
      "source": "CSCD210-D4-S2-C3-A3",
      "target": "CSCD210-D4-S2-C3"
    },
    {
      "source": "CSCD210-D4-S3",
      "target": "CSCD210-D4"
    },
    {
      "source": "CSCD210-D4-S3-C1",
      "target": "CSCD210-D4-S3"
    },
    {
      "source": "CSCD210-D4-S3-C1-A1",
      "target": "CSCD210-D4-S3-C1"
    },
    {
      "source": "CSCD210-D4-S3-C1-A2",
      "target": "CSCD210-D4-S3-C1"
    },
    {
      "source": "CSCD210-D4-S3-C1-A3",
      "target": "CSCD210-D4-S3-C1"
    },
    {
      "source": "CSCD210-D4-S3-C2",
      "target": "CSCD210-D4-S3"
    },
    {
      "source": "CSCD210-D4-S3-C2-A1",
      "target": "CSCD210-D4-S3-C2"
    },
    {
      "source": "CSCD210-D4-S3-C2-A2",
      "target": "CSCD210-D4-S3-C2"
    },
    {
      "source": "CSCD210-D4-S3-C2-A3",
      "target": "CSCD210-D4-S3-C2"
    },
    {
      "source": "CSCD210-D4-S3-C3",
      "target": "CSCD210-D4-S3"
    },
    {
      "source": "CSCD210-D4-S3-C3-A1",
      "target": "CSCD210-D4-S3-C3"
    },
    {
      "source": "CSCD210-D4-S3-C3-A2",
      "target": "CSCD210-D4-S3-C3"
    },
    {
      "source": "CSCD210-D4-S3-C3-A3",
      "target": "CSCD210-D4-S3-C3"
    },
    {
      "source": "CSCD210-D5",
      "target": "CSCD210"
    },
    {
      "source": "CSCD210-D5-S1",
      "target": "CSCD210-D5"
    },
    {
      "source": "CSCD210-D5-S1-C1",
      "target": "CSCD210-D5-S1"
    },
    {
      "source": "CSCD210-D5-S1-C1-A1",
      "target": "CSCD210-D5-S1-C1"
    },
    {
      "source": "CSCD210-D5-S1-C1-A2",
      "target": "CSCD210-D5-S1-C1"
    },
    {
      "source": "CSCD210-D5-S1-C1-A3",
      "target": "CSCD210-D5-S1-C1"
    },
    {
      "source": "CSCD210-D5-S1-C2",
      "target": "CSCD210-D5-S1"
    },
    {
      "source": "CSCD210-D5-S1-C2-A1",
      "target": "CSCD210-D5-S1-C2"
    },
    {
      "source": "CSCD210-D5-S1-C2-A2",
      "target": "CSCD210-D5-S1-C2"
    },
    {
      "source": "CSCD210-D5-S1-C2-A3",
      "target": "CSCD210-D5-S1-C2"
    },
    {
      "source": "CSCD210-D5-S1-C3",
      "target": "CSCD210-D5-S1"
    },
    {
      "source": "CSCD210-D5-S1-C3-A1",
      "target": "CSCD210-D5-S1-C3"
    },
    {
      "source": "CSCD210-D5-S1-C3-A2",
      "target": "CSCD210-D5-S1-C3"
    },
    {
      "source": "CSCD210-D5-S1-C3-A3",
      "target": "CSCD210-D5-S1-C3"
    },
    {
      "source": "CSCD210-D5-S2",
      "target": "CSCD210-D5"
    },
    {
      "source": "CSCD210-D5-S2-C1",
      "target": "CSCD210-D5-S2"
    },
    {
      "source": "CSCD210-D5-S2-C1-A1",
      "target": "CSCD210-D5-S2-C1"
    },
    {
      "source": "CSCD210-D5-S2-C1-A2",
      "target": "CSCD210-D5-S2-C1"
    },
    {
      "source": "CSCD210-D5-S2-C1-A3",
      "target": "CSCD210-D5-S2-C1"
    },
    {
      "source": "CSCD210-D5-S2-C2",
      "target": "CSCD210-D5-S2"
    },
    {
      "source": "CSCD210-D5-S2-C2-A1",
      "target": "CSCD210-D5-S2-C2"
    },
    {
      "source": "CSCD210-D5-S2-C2-A2",
      "target": "CSCD210-D5-S2-C2"
    },
    {
      "source": "CSCD210-D5-S2-C2-A3",
      "target": "CSCD210-D5-S2-C2"
    },
    {
      "source": "CSCD210-D5-S2-C3",
      "target": "CSCD210-D5-S2"
    },
    {
      "source": "CSCD210-D5-S2-C3-A1",
      "target": "CSCD210-D5-S2-C3"
    },
    {
      "source": "CSCD210-D5-S2-C3-A2",
      "target": "CSCD210-D5-S2-C3"
    },
    {
      "source": "CSCD210-D5-S2-C3-A3",
      "target": "CSCD210-D5-S2-C3"
    },
    {
      "source": "CSCD210-D5-S3",
      "target": "CSCD210-D5"
    },
    {
      "source": "CSCD210-D5-S3-C1",
      "target": "CSCD210-D5-S3"
    },
    {
      "source": "CSCD210-D5-S3-C1-A1",
      "target": "CSCD210-D5-S3-C1"
    },
    {
      "source": "CSCD210-D5-S3-C1-A2",
      "target": "CSCD210-D5-S3-C1"
    },
    {
      "source": "CSCD210-D5-S3-C1-A3",
      "target": "CSCD210-D5-S3-C1"
    },
    {
      "source": "CSCD210-D5-S3-C2",
      "target": "CSCD210-D5-S3"
    },
    {
      "source": "CSCD210-D5-S3-C2-A1",
      "target": "CSCD210-D5-S3-C2"
    },
    {
      "source": "CSCD210-D5-S3-C2-A2",
      "target": "CSCD210-D5-S3-C2"
    },
    {
      "source": "CSCD210-D5-S3-C2-A3",
      "target": "CSCD210-D5-S3-C2"
    },
    {
      "source": "CSCD210-D5-S3-C3",
      "target": "CSCD210-D5-S3"
    },
    {
      "source": "CSCD210-D5-S3-C3-A1",
      "target": "CSCD210-D5-S3-C3"
    },
    {
      "source": "CSCD210-D5-S3-C3-A2",
      "target": "CSCD210-D5-S3-C3"
    },
    {
      "source": "CSCD210-D5-S3-C3-A3",
      "target": "CSCD210-D5-S3-C3"
    },
    {
      "source": "CSCD210-D6",
      "target": "CSCD210"
    },
    {
      "source": "CSCD210-D6-S1",
      "target": "CSCD210-D6"
    },
    {
      "source": "CSCD210-D6-S1-C1",
      "target": "CSCD210-D6-S1"
    },
    {
      "source": "CSCD210-D6-S1-C1-A1",
      "target": "CSCD210-D6-S1-C1"
    },
    {
      "source": "CSCD210-D6-S1-C1-A2",
      "target": "CSCD210-D6-S1-C1"
    },
    {
      "source": "CSCD210-D6-S1-C1-A3",
      "target": "CSCD210-D6-S1-C1"
    },
    {
      "source": "CSCD210-D6-S1-C2",
      "target": "CSCD210-D6-S1"
    },
    {
      "source": "CSCD210-D6-S1-C2-A1",
      "target": "CSCD210-D6-S1-C2"
    },
    {
      "source": "CSCD210-D6-S1-C2-A2",
      "target": "CSCD210-D6-S1-C2"
    },
    {
      "source": "CSCD210-D6-S1-C2-A3",
      "target": "CSCD210-D6-S1-C2"
    },
    {
      "source": "CSCD210-D6-S1-C3",
      "target": "CSCD210-D6-S1"
    },
    {
      "source": "CSCD210-D6-S1-C3-A1",
      "target": "CSCD210-D6-S1-C3"
    },
    {
      "source": "CSCD210-D6-S1-C3-A2",
      "target": "CSCD210-D6-S1-C3"
    },
    {
      "source": "CSCD210-D6-S1-C3-A3",
      "target": "CSCD210-D6-S1-C3"
    },
    {
      "source": "CSCD210-D6-S2",
      "target": "CSCD210-D6"
    },
    {
      "source": "CSCD210-D6-S2-C1",
      "target": "CSCD210-D6-S2"
    },
    {
      "source": "CSCD210-D6-S2-C1-A1",
      "target": "CSCD210-D6-S2-C1"
    },
    {
      "source": "CSCD210-D6-S2-C1-A2",
      "target": "CSCD210-D6-S2-C1"
    },
    {
      "source": "CSCD210-D6-S2-C1-A3",
      "target": "CSCD210-D6-S2-C1"
    },
    {
      "source": "CSCD210-D6-S2-C2",
      "target": "CSCD210-D6-S2"
    },
    {
      "source": "CSCD210-D6-S2-C2-A1",
      "target": "CSCD210-D6-S2-C2"
    },
    {
      "source": "CSCD210-D6-S2-C2-A2",
      "target": "CSCD210-D6-S2-C2"
    },
    {
      "source": "CSCD210-D6-S2-C2-A3",
      "target": "CSCD210-D6-S2-C2"
    },
    {
      "source": "CSCD210-D6-S2-C3",
      "target": "CSCD210-D6-S2"
    },
    {
      "source": "CSCD210-D6-S2-C3-A1",
      "target": "CSCD210-D6-S2-C3"
    },
    {
      "source": "CSCD210-D6-S2-C3-A2",
      "target": "CSCD210-D6-S2-C3"
    },
    {
      "source": "CSCD210-D6-S2-C3-A3",
      "target": "CSCD210-D6-S2-C3"
    },
    {
      "source": "CSCD210-D6-S3",
      "target": "CSCD210-D6"
    },
    {
      "source": "CSCD210-D6-S3-C1",
      "target": "CSCD210-D6-S3"
    },
    {
      "source": "CSCD210-D6-S3-C1-A1",
      "target": "CSCD210-D6-S3-C1"
    },
    {
      "source": "CSCD210-D6-S3-C1-A2",
      "target": "CSCD210-D6-S3-C1"
    },
    {
      "source": "CSCD210-D6-S3-C1-A3",
      "target": "CSCD210-D6-S3-C1"
    },
    {
      "source": "CSCD210-D6-S3-C2",
      "target": "CSCD210-D6-S3"
    },
    {
      "source": "CSCD210-D6-S3-C2-A1",
      "target": "CSCD210-D6-S3-C2"
    },
    {
      "source": "CSCD210-D6-S3-C2-A2",
      "target": "CSCD210-D6-S3-C2"
    },
    {
      "source": "CSCD210-D6-S3-C2-A3",
      "target": "CSCD210-D6-S3-C2"
    },
    {
      "source": "CSCD210-D6-S3-C3",
      "target": "CSCD210-D6-S3"
    },
    {
      "source": "CSCD210-D6-S3-C3-A1",
      "target": "CSCD210-D6-S3-C3"
    },
    {
      "source": "CSCD210-D6-S3-C3-A2",
      "target": "CSCD210-D6-S3-C3"
    },
    {
      "source": "CSCD210-D6-S3-C3-A3",
      "target": "CSCD210-D6-S3-C3"
    },
    {
      "source": "CSCD210-D7",
      "target": "CSCD210"
    },
    {
      "source": "CSCD210-D7-S1",
      "target": "CSCD210-D7"
    },
    {
      "source": "CSCD210-D7-S1-C1",
      "target": "CSCD210-D7-S1"
    },
    {
      "source": "CSCD210-D7-S1-C1-A1",
      "target": "CSCD210-D7-S1-C1"
    },
    {
      "source": "CSCD210-D7-S1-C1-A2",
      "target": "CSCD210-D7-S1-C1"
    },
    {
      "source": "CSCD210-D7-S1-C1-A3",
      "target": "CSCD210-D7-S1-C1"
    },
    {
      "source": "CSCD210-D7-S1-C2",
      "target": "CSCD210-D7-S1"
    },
    {
      "source": "CSCD210-D7-S1-C2-A1",
      "target": "CSCD210-D7-S1-C2"
    },
    {
      "source": "CSCD210-D7-S1-C2-A2",
      "target": "CSCD210-D7-S1-C2"
    },
    {
      "source": "CSCD210-D7-S1-C2-A3",
      "target": "CSCD210-D7-S1-C2"
    },
    {
      "source": "CSCD210-D7-S1-C3",
      "target": "CSCD210-D7-S1"
    },
    {
      "source": "CSCD210-D7-S1-C3-A1",
      "target": "CSCD210-D7-S1-C3"
    },
    {
      "source": "CSCD210-D7-S1-C3-A2",
      "target": "CSCD210-D7-S1-C3"
    },
    {
      "source": "CSCD210-D7-S1-C3-A3",
      "target": "CSCD210-D7-S1-C3"
    },
    {
      "source": "CSCD210-D7-S2",
      "target": "CSCD210-D7"
    },
    {
      "source": "CSCD210-D7-S2-C1",
      "target": "CSCD210-D7-S2"
    },
    {
      "source": "CSCD210-D7-S2-C1-A1",
      "target": "CSCD210-D7-S2-C1"
    },
    {
      "source": "CSCD210-D7-S2-C1-A2",
      "target": "CSCD210-D7-S2-C1"
    },
    {
      "source": "CSCD210-D7-S2-C1-A3",
      "target": "CSCD210-D7-S2-C1"
    },
    {
      "source": "CSCD210-D7-S2-C2",
      "target": "CSCD210-D7-S2"
    },
    {
      "source": "CSCD210-D7-S2-C2-A1",
      "target": "CSCD210-D7-S2-C2"
    },
    {
      "source": "CSCD210-D7-S2-C2-A2",
      "target": "CSCD210-D7-S2-C2"
    },
    {
      "source": "CSCD210-D7-S2-C2-A3",
      "target": "CSCD210-D7-S2-C2"
    },
    {
      "source": "CSCD210-D7-S2-C3",
      "target": "CSCD210-D7-S2"
    },
    {
      "source": "CSCD210-D7-S2-C3-A1",
      "target": "CSCD210-D7-S2-C3"
    },
    {
      "source": "CSCD210-D7-S2-C3-A2",
      "target": "CSCD210-D7-S2-C3"
    },
    {
      "source": "CSCD210-D7-S2-C3-A3",
      "target": "CSCD210-D7-S2-C3"
    },
    {
      "source": "CSCD210-D7-S3",
      "target": "CSCD210-D7"
    },
    {
      "source": "CSCD210-D7-S3-C1",
      "target": "CSCD210-D7-S3"
    },
    {
      "source": "CSCD210-D7-S3-C1-A1",
      "target": "CSCD210-D7-S3-C1"
    },
    {
      "source": "CSCD210-D7-S3-C1-A2",
      "target": "CSCD210-D7-S3-C1"
    },
    {
      "source": "CSCD210-D7-S3-C1-A3",
      "target": "CSCD210-D7-S3-C1"
    },
    {
      "source": "CSCD210-D7-S3-C2",
      "target": "CSCD210-D7-S3"
    },
    {
      "source": "CSCD210-D7-S3-C2-A1",
      "target": "CSCD210-D7-S3-C2"
    },
    {
      "source": "CSCD210-D7-S3-C2-A2",
      "target": "CSCD210-D7-S3-C2"
    },
    {
      "source": "CSCD210-D7-S3-C2-A3",
      "target": "CSCD210-D7-S3-C2"
    },
    {
      "source": "CSCD210-D7-S3-C3",
      "target": "CSCD210-D7-S3"
    },
    {
      "source": "CSCD210-D7-S3-C3-A1",
      "target": "CSCD210-D7-S3-C3"
    },
    {
      "source": "CSCD210-D7-S3-C3-A2",
      "target": "CSCD210-D7-S3-C3"
    },
    {
      "source": "CSCD210-D7-S3-C3-A3",
      "target": "CSCD210-D7-S3-C3"
    },
    {
      "source": "CSCD210-D8",
      "target": "CSCD210"
    },
    {
      "source": "CSCD210-D8-S1",
      "target": "CSCD210-D8"
    },
    {
      "source": "CSCD210-D8-S1-C1",
      "target": "CSCD210-D8-S1"
    },
    {
      "source": "CSCD210-D8-S1-C1-A1",
      "target": "CSCD210-D8-S1-C1"
    },
    {
      "source": "CSCD210-D8-S1-C1-A2",
      "target": "CSCD210-D8-S1-C1"
    },
    {
      "source": "CSCD210-D8-S1-C1-A3",
      "target": "CSCD210-D8-S1-C1"
    },
    {
      "source": "CSCD210-D8-S1-C2",
      "target": "CSCD210-D8-S1"
    },
    {
      "source": "CSCD210-D8-S1-C2-A1",
      "target": "CSCD210-D8-S1-C2"
    },
    {
      "source": "CSCD210-D8-S1-C2-A2",
      "target": "CSCD210-D8-S1-C2"
    },
    {
      "source": "CSCD210-D8-S1-C2-A3",
      "target": "CSCD210-D8-S1-C2"
    },
    {
      "source": "CSCD210-D8-S1-C3",
      "target": "CSCD210-D8-S1"
    },
    {
      "source": "CSCD210-D8-S1-C3-A1",
      "target": "CSCD210-D8-S1-C3"
    },
    {
      "source": "CSCD210-D8-S1-C3-A2",
      "target": "CSCD210-D8-S1-C3"
    },
    {
      "source": "CSCD210-D8-S1-C3-A3",
      "target": "CSCD210-D8-S1-C3"
    },
    {
      "source": "CSCD210-D8-S2",
      "target": "CSCD210-D8"
    },
    {
      "source": "CSCD210-D8-S2-C1",
      "target": "CSCD210-D8-S2"
    },
    {
      "source": "CSCD210-D8-S2-C1-A1",
      "target": "CSCD210-D8-S2-C1"
    },
    {
      "source": "CSCD210-D8-S2-C1-A2",
      "target": "CSCD210-D8-S2-C1"
    },
    {
      "source": "CSCD210-D8-S2-C1-A3",
      "target": "CSCD210-D8-S2-C1"
    },
    {
      "source": "CSCD210-D8-S2-C2",
      "target": "CSCD210-D8-S2"
    },
    {
      "source": "CSCD210-D8-S2-C2-A1",
      "target": "CSCD210-D8-S2-C2"
    },
    {
      "source": "CSCD210-D8-S2-C2-A2",
      "target": "CSCD210-D8-S2-C2"
    },
    {
      "source": "CSCD210-D8-S2-C2-A3",
      "target": "CSCD210-D8-S2-C2"
    },
    {
      "source": "CSCD210-D8-S2-C3",
      "target": "CSCD210-D8-S2"
    },
    {
      "source": "CSCD210-D8-S2-C3-A1",
      "target": "CSCD210-D8-S2-C3"
    },
    {
      "source": "CSCD210-D8-S2-C3-A2",
      "target": "CSCD210-D8-S2-C3"
    },
    {
      "source": "CSCD210-D8-S2-C3-A3",
      "target": "CSCD210-D8-S2-C3"
    },
    {
      "source": "CSCD210-D8-S3",
      "target": "CSCD210-D8"
    },
    {
      "source": "CSCD210-D8-S3-C1",
      "target": "CSCD210-D8-S3"
    },
    {
      "source": "CSCD210-D8-S3-C1-A1",
      "target": "CSCD210-D8-S3-C1"
    },
    {
      "source": "CSCD210-D8-S3-C1-A2",
      "target": "CSCD210-D8-S3-C1"
    },
    {
      "source": "CSCD210-D8-S3-C1-A3",
      "target": "CSCD210-D8-S3-C1"
    },
    {
      "source": "CSCD210-D8-S3-C2",
      "target": "CSCD210-D8-S3"
    },
    {
      "source": "CSCD210-D8-S3-C2-A1",
      "target": "CSCD210-D8-S3-C2"
    },
    {
      "source": "CSCD210-D8-S3-C2-A2",
      "target": "CSCD210-D8-S3-C2"
    },
    {
      "source": "CSCD210-D8-S3-C2-A3",
      "target": "CSCD210-D8-S3-C2"
    },
    {
      "source": "CSCD210-D8-S3-C3",
      "target": "CSCD210-D8-S3"
    },
    {
      "source": "CSCD210-D8-S3-C3-A1",
      "target": "CSCD210-D8-S3-C3"
    },
    {
      "source": "CSCD210-D8-S3-C3-A2",
      "target": "CSCD210-D8-S3-C3"
    },
    {
      "source": "CSCD210-D8-S3-C3-A3",
      "target": "CSCD210-D8-S3-C3"
    },
    {
      "source": "CSCD210-D9",
      "target": "CSCD210"
    },
    {
      "source": "CSCD210-D9-S1",
      "target": "CSCD210-D9"
    },
    {
      "source": "CSCD210-D9-S1-C1",
      "target": "CSCD210-D9-S1"
    },
    {
      "source": "CSCD210-D9-S1-C1-A1",
      "target": "CSCD210-D9-S1-C1"
    },
    {
      "source": "CSCD210-D9-S1-C1-A2",
      "target": "CSCD210-D9-S1-C1"
    },
    {
      "source": "CSCD210-D9-S1-C1-A3",
      "target": "CSCD210-D9-S1-C1"
    },
    {
      "source": "CSCD210-D9-S1-C2",
      "target": "CSCD210-D9-S1"
    },
    {
      "source": "CSCD210-D9-S1-C2-A1",
      "target": "CSCD210-D9-S1-C2"
    },
    {
      "source": "CSCD210-D9-S1-C2-A2",
      "target": "CSCD210-D9-S1-C2"
    },
    {
      "source": "CSCD210-D9-S1-C2-A3",
      "target": "CSCD210-D9-S1-C2"
    },
    {
      "source": "CSCD210-D9-S1-C3",
      "target": "CSCD210-D9-S1"
    },
    {
      "source": "CSCD210-D9-S1-C3-A1",
      "target": "CSCD210-D9-S1-C3"
    },
    {
      "source": "CSCD210-D9-S1-C3-A2",
      "target": "CSCD210-D9-S1-C3"
    },
    {
      "source": "CSCD210-D9-S1-C3-A3",
      "target": "CSCD210-D9-S1-C3"
    },
    {
      "source": "CSCD210-D9-S2",
      "target": "CSCD210-D9"
    },
    {
      "source": "CSCD210-D9-S2-C1",
      "target": "CSCD210-D9-S2"
    },
    {
      "source": "CSCD210-D9-S2-C1-A1",
      "target": "CSCD210-D9-S2-C1"
    },
    {
      "source": "CSCD210-D9-S2-C1-A2",
      "target": "CSCD210-D9-S2-C1"
    },
    {
      "source": "CSCD210-D9-S2-C1-A3",
      "target": "CSCD210-D9-S2-C1"
    },
    {
      "source": "CSCD210-D9-S2-C2",
      "target": "CSCD210-D9-S2"
    },
    {
      "source": "CSCD210-D9-S2-C2-A1",
      "target": "CSCD210-D9-S2-C2"
    },
    {
      "source": "CSCD210-D9-S2-C2-A2",
      "target": "CSCD210-D9-S2-C2"
    },
    {
      "source": "CSCD210-D9-S2-C2-A3",
      "target": "CSCD210-D9-S2-C2"
    },
    {
      "source": "CSCD210-D9-S2-C3",
      "target": "CSCD210-D9-S2"
    },
    {
      "source": "CSCD210-D9-S2-C3-A1",
      "target": "CSCD210-D9-S2-C3"
    },
    {
      "source": "CSCD210-D9-S2-C3-A2",
      "target": "CSCD210-D9-S2-C3"
    },
    {
      "source": "CSCD210-D9-S2-C3-A3",
      "target": "CSCD210-D9-S2-C3"
    },
    {
      "source": "CSCD210-D9-S3",
      "target": "CSCD210-D9"
    },
    {
      "source": "CSCD210-D9-S3-C1",
      "target": "CSCD210-D9-S3"
    },
    {
      "source": "CSCD210-D9-S3-C1-A1",
      "target": "CSCD210-D9-S3-C1"
    },
    {
      "source": "CSCD210-D9-S3-C1-A2",
      "target": "CSCD210-D9-S3-C1"
    },
    {
      "source": "CSCD210-D9-S3-C1-A3",
      "target": "CSCD210-D9-S3-C1"
    },
    {
      "source": "CSCD210-D9-S3-C2",
      "target": "CSCD210-D9-S3"
    },
    {
      "source": "CSCD210-D9-S3-C2-A1",
      "target": "CSCD210-D9-S3-C2"
    },
    {
      "source": "CSCD210-D9-S3-C2-A2",
      "target": "CSCD210-D9-S3-C2"
    },
    {
      "source": "CSCD210-D9-S3-C2-A3",
      "target": "CSCD210-D9-S3-C2"
    },
    {
      "source": "CSCD210-D9-S3-C3",
      "target": "CSCD210-D9-S3"
    },
    {
      "source": "CSCD210-D9-S3-C3-A1",
      "target": "CSCD210-D9-S3-C3"
    },
    {
      "source": "CSCD210-D9-S3-C3-A2",
      "target": "CSCD210-D9-S3-C3"
    },
    {
      "source": "CSCD210-D9-S3-C3-A3",
      "target": "CSCD210-D9-S3-C3"
    }
  ]
}
